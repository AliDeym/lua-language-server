[hook]
type = 'table'
[[.source]]
type = 'global'
``````````
type = 'library'
name = 'hook'

<default>
type = 'function'
parent = {
	1 = {
		type = 'global',
		name = 'hook'
	},
	2 = {
		type = 'library',
		name = 'hook'
	}
}

[Add]
description = 'Add a hook to be called upon the given event occurring.\r\n\r\n**Scope:** Shared'
[[.args]]
name = 'eventName'
type = 'string'
description = 'The event to hook on to. This can be any GM function, gameevent after using <page>gameevent.Listen</page>, or custom hook run with <page>hook.Call</page> or <page>hook.Run</page>.'
``````````
name = 'identifier'
type = 'any'
description = 'The unique identifier, usually a string. This can be used elsewhere in the code to replace or remove the hook. The identifier **should** be unique so that you do not accidentally override some other mods hook, unless that\'s what you are trying to do.\r\n\r\nThe identifier can be either a <page>string</page>, or a <page>table</page>/object with an IsValid function defined such as an <page>Entity</page> or <page>Panel</page>. <page>number</page>s and <page>boolean</page>s, for example, are not allowed.\r\n\r\nIf the identifier is a table/object, it will be inserted in front of the other arguments in the callback and the hook will be called as long as it\'s valid. However, as soon as IsValid( identifier ) returns false, the hook will be removed.'
``````````
name = 'func'
type = 'function'
description = 'The function to be called, arguments given to it depend on the .\r\n<warning>Returning any value besides nil from the hook\'s function will stop other hooks of the same event down the loop from being executed. Only return a value when absolutely necessary and when you know what you are doing.\r\n\r\nIt WILL break other addons.</warning>'
[[.enums]]
name = 'eventName'
enum = 'PlayerSpawned'
description = 'Called when player spawns.'
default = true
``````````
name = 'eventName'
enum = 'PlayerDisconnected'
description = 'Called whenever player disconnects.'

[Call]
description = 'Calls all hooks associated with the given event until one returns something other than nil, and then returns that data.\r\n\r\nIn almost all cases, you should use <page>hook.Run</page> instead - it calls hook.Call internally but supplies the gamemode table by itself, making your code neater.\r\n\r\n**Returns:** Return data from called hooks. Limited to 6 return values\r\n\r\n**Scope:** Shared'
[[.args]]
name = 'eventName'
type = 'string'
description = 'The event to call hooks for'
``````````
name = 'gamemodeTable'
type = 'table'
description = 'If the gamemode is specified, the gamemode hook within will be called, otherwise not'
``````````
name = 'args'
type = 'vararg'
description = 'The arguments to be passed to the hooks'
[[.returns]]
type = 'vararg'

[GetTable]
description = 'Returns a list of all the hooks registered with <page>hook.Add</page>.\r\n\r\n**Returns:** A table of tables. See below for output example.\r\n\r\n**Scope:** Shared'
[[.returns]]
type = 'table'

[Remove]
description = 'Removes the hook with the supplied identifier from the given event.\r\n\r\n**Scope:** Shared'
[[.args]]
name = 'eventName'
type = 'string'
description = 'The event name.'
``````````
name = 'identifier'
type = 'any'
description = 'The unique identifier of the hook to remove, usually a string.'

[Run]
description = 'Calls hooks associated with the given event.\r\n\r\nCalls all hooks until one returns something other than nil and then returns that data.\r\n\r\n\r\nIf no hook returns any data, it will try to call the GAMEMODE:<eventName> alternative, if one exists.\r\n\r\nThis function internally calls <page>hook.Call</page>.\r\n\r\nSee also: <page>gamemode.Call</page> - same as this, but does not call hooks if the gamemode hasn\'t defined the function.\r\n\r\n**Returns:** Returned data from called hooks\r\n\r\n**Scope:** Shared'
[[.args]]
name = 'eventName'
type = 'string'
description = 'The event to call hooks for'
``````````
name = 'args'
type = 'vararg'
description = 'The arguments to be passed to the hooks'
[[.returns]]
type = 'any'

[EndTouch]
type = 'interface'
description = '\r\n\r\n**Scope:** Client'
customsnip = 'Add("EndTouch", "${1:name}", function()\n\t$0\nend)'

[GetTracerShootPos]
type = 'interface'
description = 'Used to get the "real" start position of a trace, for weapon tracer effects.\r\n\r\n"real" meaning in 3rd person, the 3rd person position will be used, in first person the first person position will be used.\r\n```lua\rpos: Vector\r\n--Default position if we fail\r\nent: Weapon\r\n--The weapon to use.\r\nattachment: number\r\n--Attachment ID of on the weapon "muzzle", to use as the start position.\r\n\r\n<note>Please note that it is expected that the same attachment ID is used on both, the world and the view model.</note>\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param pos Vector\n---@param ent Weapon\n---@param attachment number'
customsnip = 'Add("GetTracerShootPos", "${1:name}", function(pos, ent, attachment)\n\t$0\nend)'

[Init]
type = 'interface'
description = 'Called when the effect is created.\r\n```lua\reffectData: CEffectData\r\n--The effect data used to create the effect.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param effectData CEffectData'
customsnip = 'Add("Init", "${1:name}", function(effectData)\n\t$0\nend)'

[PhysicsCollide]
type = 'interface'
description = 'Called when the effect collides with anything.\r\n```lua\rcolData: table\r\n--Information regarding the collision. See <page>Structures/CollisionData</page>\r\ncollider: PhysObj\r\n--The physics object of the entity that collided with the effect.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param colData table\n---@param collider PhysObj'
customsnip = 'Add("PhysicsCollide", "${1:name}", function(colData, collider)\n\t$0\nend)'

[Render]
type = 'interface'
description = 'Called when the effect should be rendered.\r\n\r\n**Scope:** Client'
customsnip = 'Add("Render", "${1:name}", function()\n\t$0\nend)'

[StartTouch]
type = 'interface'
description = '\r\n\r\n**Scope:** Client'
customsnip = 'Add("StartTouch", "${1:name}", function()\n\t$0\nend)'

[Think]
type = 'interface'
description = 'Called when the effect should think, return false to kill the effect.\r\n\r\n**Scope:** Client'
customsnip = 'Add("Think", "${1:name}", function()\n\t$0\nend)'

[Touch]
type = 'interface'
description = '\r\n\r\n**Scope:** Client'
customsnip = 'Add("Touch", "${1:name}", function()\n\t$0\nend)'

[AcceptInput]
type = 'interface'
description = 'Called when another entity fires an event to this entity.\r\n```lua\rinputName: string\r\n--The name of the input that was triggered.\r\nactivator: Entity\r\n--The initial cause for the input getting triggered. (EG the player who pushed a button)\r\ncaller: Entity\r\n--The entity that directly triggered the input. (EG the button that was pushed)\r\ndata: string\r\n--The data passed.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param inputName string\n---@param activator Entity\n---@param caller Entity\n---@param data string'
customsnip = 'Add("AcceptInput", "${1:name}", function(inputName, activator, caller, data)\n\t$0\nend)'

[CalcAbsolutePosition]
type = 'interface'
description = 'Called whenever the entity\'s position changes. A callback for when an entity\'s angle changes is available via <page>Entity:AddCallback</page>.\r\n\r\nLike <page>ENTITY:RenderOverride</page>, this hook works on any entity (scripted or not) it is applied on.\r\n\r\n<note>If EFL_DIRTY_ABSTRANSFORM is set on the entity, this will be called serverside only; otherwise, this will be called clientside only. This means serverside calls of <page>Entity:SetPos</page> without the EFL_DIRTY_ABSTRANSFORM flag enabled (most cases) will be called clientside only.</note>\r\n\r\n<note>The give concommand will call this hook serverside only upon entity spawn.</note>\r\n```lua\rpos: Vector\r\n--The entity\'s actual position. May differ from <page>Entity:GetPos</page>\r\nang: Angle\r\n--The entity\'s actual angles. May differ from <page>Entity:GetAngles</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param pos Vector\n---@param ang Angle'
customsnip = 'Add("CalcAbsolutePosition", "${1:name}", function(pos, ang)\n\t$0\nend)'

[CanProperty]
type = 'interface'
description = 'Controls if a property can be used on this entity or not.\r\n\r\nThis hook will only work in Sandbox derived gamemodes that do not have <page>SANDBOX:CanProperty</page> overridden.\r\n\r\n<note>This hook will work on ALL entities, not just the scripted ones (SENTs)</note>\r\n```lua\rply: Player\r\n--Player, that tried to use the property\r\nproperty: string\r\n--Class of the property that is tried to use, for example - bonemanipulate\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param property string'
customsnip = 'Add("CanProperty", "${1:name}", function(ply, property)\n\t$0\nend)'

[CreateSchedulesInternal]
type = 'interface'
description = '<internal></internal>Called just before <page>ENTITY:Initialize</page> for "ai" type entities only.\r\n\r\n**Scope:** Server'
customsnip = 'Add("CreateSchedulesInternal", "${1:name}", function()\n\t$0\nend)'

[DoImpactEffect]
type = 'interface'
description = 'Called so the entity can override the bullet impact effects it makes.\r\n\r\n<note>This hook only works for the "anim" type entities.</note>\r\n```lua\rtr: table\r\n--A <page>Structures/TraceResult</page> from the bullet\'s start point to the impact point\r\ndamageType: number\r\n--The damage type of bullet. See <page>Enums/DMG</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param tr table\n---@param damageType number'
customsnip = 'Add("DoImpactEffect", "${1:name}", function(tr, damageType)\n\t$0\nend)'

[DoingEngineSchedule]
type = 'interface'
description = 'Called whenever an engine schedule is being ran.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("DoingEngineSchedule", "${1:name}", function()\n\t$0\nend)'

[DoSchedule]
type = 'interface'
description = 'Runs a Lua schedule. Runs tasks inside the schedule.\r\n```lua\rsched: table\r\n--The schedule to run.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param sched table'
customsnip = 'Add("DoSchedule", "${1:name}", function(sched)\n\t$0\nend)'

[Draw]
type = 'interface'
description = 'Called if and when the entity should be drawn opaquely, based on the <page>Entity:GetRenderGroup</page> of the entity.\r\n\r\nSee <page>Structures/ENT</page> and <page>Enums/RENDERGROUP</page> for more information.\r\n\r\nSee also <page>ENTITY:DrawTranslucent</page>.\r\n```lua\rflags: number\r\n--The bit flags from <page>Enums/STUDIO</page>\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param flags number'
customsnip = 'Add("Draw", "${1:name}", function(flags)\n\t$0\nend)'

[DrawTranslucent]
type = 'interface'
description = 'Called when the entity should be drawn translucently. If your scripted entity has a translucent model, it will be invisible unless it is drawn here.\r\n```lua\rflags: number\r\n--The bit flags from <page>Enums/STUDIO</page>\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param flags number'
customsnip = 'Add("DrawTranslucent", "${1:name}", function(flags)\n\t$0\nend)'

[EndTouch]
type = 'interface'
description = 'Called when the entity stops touching another entity.\r\n\r\n<warning>This only works for **brush** entities and for entities that have <page>Entity:SetTrigger</page> set to true.</warning>\r\n```lua\rentity: Entity\r\n--The entity which was touched.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param entity Entity'
customsnip = 'Add("EndTouch", "${1:name}", function(entity)\n\t$0\nend)'

[EngineScheduleFinish]
type = 'interface'
description = 'Called whenever an engine schedule is finished.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("EngineScheduleFinish", "${1:name}", function()\n\t$0\nend)'

[ExpressionFinished]
type = 'interface'
description = 'Called when an NPC\'s expression has finished.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rstrExp: string\r\n--The path of the expression.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param strExp string'
customsnip = 'Add("ExpressionFinished", "${1:name}", function(strExp)\n\t$0\nend)'

[FireAnimationEvent]
type = 'interface'
description = 'Called before firing clientside animation events, such as muzzle flashes or shell ejections.\r\n\r\nSee <page>ENTITY:HandleAnimEvent</page> for the serverside version.\r\n\r\n<note>This hook only works on "anim", "nextbot" and "ai" type entities.</note>\r\n```lua\rpos: Vector\r\n--Position of the effect\r\nang: Angle\r\n--Angle of the effect\r\nevent: number\r\n--The event ID of happened even. See [this page](http://developer.valvesoftware.com/wiki/Animation_Events).\r\nname: string\r\n--Name of the event\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param pos Vector\n---@param ang Angle\n---@param event number\n---@param name string'
customsnip = 'Add("FireAnimationEvent", "${1:name}", function(pos, ang, event, name)\n\t$0\nend)'

[GetAttackSpread]
type = 'interface'
description = 'Called to determine how good an NPC is at using a particular weapon.\r\n\r\n<note>"ai" base only</note>\r\n```lua\rwep: Entity\r\n--The weapon being used by the NPC.\r\ntarget: Entity\r\n--The target the NPC is attacking\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param wep Entity\n---@param target Entity'
customsnip = 'Add("GetAttackSpread", "${1:name}", function(wep, target)\n\t$0\nend)'

[GetRelationship]
type = 'interface'
description = 'Called when scripted NPC needs to check how he "feels" against another entity, such as when <page>NPC:Disposition</page> is called.\r\n```lua\rent: Entity\r\n--The entity in question\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("GetRelationship", "${1:name}", function(ent)\n\t$0\nend)'

[GetRenderMesh]
type = 'interface'
description = 'Specify a mesh that should be rendered instead of this SENT\'s model.\r\n\r\n**Scope:** Client'
customsnip = 'Add("GetRenderMesh", "${1:name}", function()\n\t$0\nend)'

[GravGunPickupAllowed]
type = 'interface'
description = 'Called by <page>GM:GravGunPickupAllowed</page> on ALL entites in Sandbox-derived  gamemodes and acts as an override.\r\n```lua\rply: Player\r\n--The player aiming at us\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("GravGunPickupAllowed", "${1:name}", function(ply)\n\t$0\nend)'

[GravGunPunt]
type = 'interface'
description = 'Called when this entity is about to be punted with the gravity gun (primary fire).\r\n\r\nOnly works in Sandbox derived gamemodes and only if <page>GM:GravGunPunt</page> is not overridden.\r\n```lua\rply: Player\r\n--The player pressing left-click with the gravity gun at an entity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("GravGunPunt", "${1:name}", function(ply)\n\t$0\nend)'

[HandleAnimEvent]
type = 'interface'
description = 'Called before firing serverside animation events, such as weapon reload, drawing and holstering for NPCs, scripted sequences, etc.\r\n\r\nSee <page>ENTITY:FireAnimationEvent</page> for the clientside version.\r\n\r\n<note>This hook only works on "anim", "ai" and "nextbot" type entities.</note>\r\n```lua\revent: number\r\n--The event ID of happened even. See [this page](http://developer.valvesoftware.com/wiki/Animation_Events).\r\neventTime: number\r\n--The absolute time this event occurred using <page>Global.CurTime</page>.\r\ncycle: number\r\n--The frame this event occurred as a number between 0 and 1.\r\ntype: number\r\n--Event type. See [the Source SDK](https://github.com/ValveSoftware/source-sdk-2013/blob/master/mp/src/game/shared/eventlist.h#L14-L23).\r\noptions: string\r\n--Name or options of this event.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param event number\n---@param eventTime number\n---@param cycle number\n---@param type number\n---@param options string'
customsnip = 'Add("HandleAnimEvent", "${1:name}", function(event, eventTime, cycle, type, options)\n\t$0\nend)'

[ImpactTrace]
type = 'interface'
description = 'Called when a bullet trace hits this entity and allows you to override the default behavior by returning true.\r\n```lua\rtraceResult: table\r\n--The trace that hit this entity as a <page>Structures/TraceResult</page>.\r\ndamageType: number\r\n--The damage bits associated with the trace, see <page>Enums/DMG</page>\r\ncustomImpactName: string\r\n--The effect name to override the impact effect with.\r\nPossible arguments are ImpactJeep, AirboatGunImpact, HelicopterImpact, ImpactGunship.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param traceResult table\n---@param damageType number\n---@param customImpactName string'
customsnip = 'Add("ImpactTrace", "${1:name}", function(traceResult, damageType, customImpactName)\n\t$0\nend)'

[Initialize]
type = 'interface'
description = 'Called when the entity is created. This is called when you <page>Entity:Spawn</page> the custom entity.\r\n\r\nThis is called **after** <page>ENTITY:SetupDataTables</page> and <page>GM:OnEntityCreated</page>.\r\n\r\n<bug issue="2732">This is sometimes not called clientside. You can work around this by setting a variable in Initialize and check if it exists in <page>ENTITY:Think</page>. See the example below.</bug>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Initialize", "${1:name}", function()\n\t$0\nend)'

[IsJumpLegal]
type = 'interface'
description = 'Called when deciding if the Scripted NPC should be able to perform a certain jump or not.\r\n<note>This is only called for "ai" type entities</note>\r\n```lua\rstartPos: Vector\r\n--Start of the jump\r\napex: Vector\r\n--Apex point of the jump\r\nendPos: Vector\r\n--The landing position\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param startPos Vector\n---@param apex Vector\n---@param endPos Vector'
customsnip = 'Add("IsJumpLegal", "${1:name}", function(startPos, apex, endPos)\n\t$0\nend)'

[KeyValue]
type = 'interface'
description = 'Called when the engine sets a value for this scripted entity.\r\n\r\nThis hook is called **before** <page>ENTITY:Initialize</page> when the key-values are set by the map.<br>\r\nOtherwise this hook will be called whenever <page>Entity:SetKeyValue</page> is called on the entity.\r\n\r\nSee <page>GM:EntityKeyValue</page> for a hook that works for all entities.\r\n\r\nSee <page>WEAPON:KeyValue</page> for a hook that works for scripted weapons.\r\n```lua\rkey: string\r\n--The key that was affected.\r\nvalue: string\r\n--The new value.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param key string\n---@param value string'
customsnip = 'Add("KeyValue", "${1:name}", function(key, value)\n\t$0\nend)'

[NextTask]
type = 'interface'
description = 'Start the next task in specific schedule.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rsched: table\r\n--The schedule to start next task in.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param sched table'
customsnip = 'Add("NextTask", "${1:name}", function(sched)\n\t$0\nend)'

[OnChangeActivity]
type = 'interface'
description = 'Called when the NPC has changed its activity.\r\n\r\n<note>This hook only works for `ai` type entities.</note>\r\n```lua\ract: number\r\n--The new activity. See <page>Enums/ACT</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param act number'
customsnip = 'Add("OnChangeActivity", "${1:name}", function(act)\n\t$0\nend)'

[OnCondition]
type = 'interface'
description = 'Called each time the NPC updates its condition.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rconditionID: number\r\n--The ID of condition. See <page>NPC:ConditionName</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param conditionID number'
customsnip = 'Add("OnCondition", "${1:name}", function(conditionID)\n\t$0\nend)'

[OnDuplicated]
type = 'interface'
description = 'Called on any entity after it has been created by the <page>duplicator</page> and before any bone/entity modifiers have been applied.\r\n\r\nThis hook is called after <page>ENTITY:Initialize</page> and before <page>ENTITY:PostEntityPaste</page>.\r\n```lua\rentTable: table\r\n--<page>Structures/EntityCopyData</page> of the source entity.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param entTable table'
customsnip = 'Add("OnDuplicated", "${1:name}", function(entTable)\n\t$0\nend)'

[OnEntityCopyTableFinish]
type = 'interface'
description = 'Called after duplicator finishes saving the entity, allowing you to modify the save data.\r\n\r\nThis is called after <page>ENTITY:PostEntityCopy</page>.\r\n```lua\rdata: table\r\n--The save <page>Structures/EntityCopyData</page> that you can modify.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param data table'
customsnip = 'Add("OnEntityCopyTableFinish", "${1:name}", function(data)\n\t$0\nend)'

[OnReloaded]
type = 'interface'
description = 'Called when the entity is reloaded by the lua auto-refresh system, i.e. when the developer edits the lua file for the entity while the game is running.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnReloaded", "${1:name}", function()\n\t$0\nend)'

[OnRemove]
type = 'interface'
description = 'Called when the entity is about to be removed.\r\n\r\nSee also <page>Entity:CallOnRemove</page>, which can even be used on engine (non-Lua) entities.\r\n\r\n## Clientside behaviour remarks\r\n\r\n\r\n\r\nThis hook may be called at odd times (when entity has actually not yet been removed from the server). This happens during fullupdate with the <page>ENTITY:Initialize</page> function not being called even when the entity reappears.\r\nYou can debug this behaviour by enabling cheats and running **cl_fullupdate** on the client.\r\n\r\n<page>GM:NotifyShouldTransmit</page> can be used to circumvent this problem. <page>ENTITY:Think</page> can also be used to detect that the entity has reappeared. You may reinitialize any necessary data in these hooks.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnRemove", "${1:name}", function()\n\t$0\nend)'

[OnRestore]
type = 'interface'
description = 'Called when the entity is reloaded from a Source Engine save (not the Sandbox saves or dupes) or on a changelevel (for example Half-Life 2 campaign level transitions).\r\n\r\nFor the <page>duplicator</page> callbacks, see <page>ENTITY:OnDuplicated</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnRestore", "${1:name}", function()\n\t$0\nend)'

[OnTakeDamage]
type = 'interface'
description = 'Called when the entity is taking damage.\r\n\r\n<warning>Calling <page>Entity:TakeDamage</page>, <page>Entity:TakeDamageInfo</page>, <page>Entity:DispatchTraceAttack</page>, or <page>Player:TraceHullAttack</page> (if the entity is hit) in this hook on the victim entity can cause infinite loops since the hook will be called again. Make sure to setup recursion safeguards like the example below.</warning>\r\n```lua\rdamage: CTakeDamageInfo\r\n--The damage to be applied to the entity.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param damage CTakeDamageInfo'
customsnip = 'Add("OnTakeDamage", "${1:name}", function(damage)\n\t$0\nend)'

[OnTaskComplete]
type = 'interface'
description = 'Called from the engine when TaskComplete is called.\r\nThis allows us to move onto the next task - even when TaskComplete was called from an engine side task.\r\n\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("OnTaskComplete", "${1:name}", function()\n\t$0\nend)'

[PassesTriggerFilters]
type = 'interface'
description = 'Polls whenever the entity should trigger the brush.\r\n\r\n<warning>This hook is broken and will not work without code below</warning>\r\n```lua\rent: Entity\r\n--The entity that is about to trigger.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("PassesTriggerFilters", "${1:name}", function(ent)\n\t$0\nend)'

[PhysicsCollide]
type = 'interface'
description = 'Called when the entity collides with anything. The move type and solid type must be VPHYSICS for the hook to be called.\r\n\r\n<note>If you want to use this hook on default/engine/non-Lua entites ( like prop_physics ), use <page>Entity:AddCallback</page> instead! This page describes a hook for Lua entities</note>\r\n```lua\rcolData: table\r\n--Information regarding the collision. See <page>Structures/CollisionData</page>.\r\ncollider: PhysObj\r\n--The physics object that collided.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param colData table\n---@param collider PhysObj'
customsnip = 'Add("PhysicsCollide", "${1:name}", function(colData, collider)\n\t$0\nend)'

[PhysicsSimulate]
type = 'interface'
description = 'Called from the Entity\'s motion controller to simulate physics.\r\n\r\nThis will only be called after using <page>Entity:StartMotionController</page> on a scripted entity of "anim" type.\r\n\r\n<note>This hook can work on the CLIENT if you call <page>Entity:StartMotionController</page> and use <page>Entity:AddToMotionController</page> on the physics objects you want to control</note>\r\n\r\n<warning>Do not use functions such as <page>PhysObj:EnableCollisions</page> or <page>PhysObj:EnableGravity</page> in this hook as they\'re very likely to crash your game. You may want to use <page>ENTITY:PhysicsUpdate</page> instead.</warning>\r\n```lua\rphys: PhysObj\r\n--The physics object of the entity.\r\ndeltaTime: number\r\n--Time since the last call.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param phys PhysObj\n---@param deltaTime number'
customsnip = 'Add("PhysicsSimulate", "${1:name}", function(phys, deltaTime)\n\t$0\nend)'

[PhysicsUpdate]
type = 'interface'
description = 'Called whenever the physics of the entity are updated.\r\n\r\n<warning>This hook won\'t be called if the Entity\'s <page>PhysObj</page> goes asleep</warning>\r\n```lua\rphys: PhysObj\r\n--The physics object of the entity.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param phys PhysObj'
customsnip = 'Add("PhysicsUpdate", "${1:name}", function(phys)\n\t$0\nend)'

[PostEntityCopy]
type = 'interface'
description = 'Called after the duplicator finished copying the entity.\r\n\r\nSee also <page>ENTITY:PreEntityCopy</page> and <page>ENTITY:PostEntityPaste</page>.\r\n\r\n**Scope:** Server'
customsnip = 'Add("PostEntityCopy", "${1:name}", function()\n\t$0\nend)'

[PostEntityPaste]
type = 'interface'
description = 'Called after the <page>duplicator</page> pastes the entity, after the bone/entity modifiers have been applied to the entity.\r\n\r\nThis hook is called after <page>ENTITY:OnDuplicated</page>.\r\n```lua\rply: Player\r\n--The player who pasted the entity.\r\n\r\n<warning>This may not be a valid player in some circumstances. For example, when a save is loaded from the main menu, this hook will be called before the player is spawned. This argument will be a NULL entity in that case.</warning>\r\n<bug pull="1408">This will be nil for invalid players.</bug>\r\nent: Entity\r\n--The entity itself. Same as \'self\'.\r\ncreatedEntities: table\r\n--All entities that are within the placed dupe. <note>The keys of each value in this table are the original entity indexes when the duplication was created. This can be utilized to restore entity references that don\'t get saved in duplications.</note>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity\n---@param createdEntities table'
customsnip = 'Add("PostEntityPaste", "${1:name}", function(ply, ent, createdEntities)\n\t$0\nend)'

[PreEntityCopy]
type = 'interface'
description = 'Called before the duplicator copies the entity.\r\n\r\nIf you are looking for a way to make the duplicator spawn another entity when duplicated. ( For example, you duplicate a "prop_physics", but you want the duplicator to spawn "prop_physics_my" ), you should add prop_physics.ClassOverride = "prop_physics_my". The duplication table should be also stored on that prop_physics, not on prop_physics_my.\r\n\r\n**Scope:** Server'
customsnip = 'Add("PreEntityCopy", "${1:name}", function()\n\t$0\nend)'

[RenderOverride]
type = 'interface'
description = 'Called instead of the engine drawing function of the entity. This hook works on any entity (scripted or not) it is applied on.\r\n\r\nThis does not work on "physgun_beam", use <page>GM:DrawPhysgunBeam</page> instead.\r\n\r\n<note>As a downside of this implementation, only one RenderOverride may be applied at a time.</note>\r\n\r\n<bug issue="3292">Drawing a viewmodel in this function will cause <page>GM:PreDrawViewModel</page>, <page>WEAPON:PreDrawViewModel</page>, <page>WEAPON:ViewModelDrawn</page>, <page>GM:PostDrawViewModel</page>, and <page>WEAPON:PostDrawViewModel</page> to be called twice.</bug>\r\n\r\n<bug issue="3299">This is called before PrePlayerDraw for players. If this function exists at all on a player, their worldmodel will always be rendered regardless of PrePlayerDraw\'s return.</bug>\r\n\r\n**Scope:** Client'
customsnip = 'Add("RenderOverride", "${1:name}", function()\n\t$0\nend)'

[RunAI]
type = 'interface'
description = 'Called from the engine every 0.1 seconds.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("RunAI", "${1:name}", function()\n\t$0\nend)'

[RunEngineTask]
type = 'interface'
description = 'Called when an engine task is ran on the entity.\r\n\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rtaskID: number\r\n--The task ID, see [ai_task.h](https://github.com/ValveSoftware/source-sdk-2013/blob/55ed12f8d1eb6887d348be03aee5573d44177ffb/mp/src/game/server/ai_task.h#L89-L502)\r\ntaskData: number\r\n--The task data.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param taskID number\n---@param taskData number'
customsnip = 'Add("RunEngineTask", "${1:name}", function(taskID, taskData)\n\t$0\nend)'

[RunTask]
type = 'interface'
description = 'Called every think on running task.\r\nThe actual task function should tell us when the task is finished.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rtask: table\r\n--The task to run\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param task table'
customsnip = 'Add("RunTask", "${1:name}", function(task)\n\t$0\nend)'

[ScheduleFinished]
type = 'interface'
description = 'Called whenever a schedule is finished.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("ScheduleFinished", "${1:name}", function()\n\t$0\nend)'

[SelectSchedule]
type = 'interface'
description = 'Set the schedule we should be playing right now.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\riNPCState: number\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param iNPCState number'
customsnip = 'Add("SelectSchedule", "${1:name}", function(iNPCState)\n\t$0\nend)'

[SetAutomaticFrameAdvance]
type = 'interface'
description = 'Toggles automatic frame advancing for animated sequences on an entity.\r\n\r\nThis has the same effect as setting the ``ENT.AutomaticFrameAdvance`` property. (See <page>Structures/ENT</page>)\r\n```lua\renable: boolean\r\n--Whether or not to set automatic frame advancing.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param enable boolean'
customsnip = 'Add("SetAutomaticFrameAdvance", "${1:name}", function(enable)\n\t$0\nend)'

[SetTask]
type = 'interface'
description = 'Sets the current task.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rtask: table\r\n--The task to set.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param task table'
customsnip = 'Add("SetTask", "${1:name}", function(task)\n\t$0\nend)'

[SetupDataTables]
type = 'interface'
description = 'Called when the entity should set up its <page text=" Data Tables">Networking_Entities</page>.\r\n\r\nThis is a much better option than using Set/Get Networked Values.\r\n\r\nThis hook is called after <page>GM:OnEntityCreated</page> and <page>GM:NetworkEntityCreated</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("SetupDataTables", "${1:name}", function()\n\t$0\nend)'

[SpawnFunction]
type = 'interface'
description = 'This is the spawn function. It\'s called when a player spawns the entity from the spawnmenu.\r\n\r\nIf you want to make your SENT spawnable you need this function to properly create the entity.\r\n\r\n<warning>Unlike other ENTITY functions, the "self" parameter of this function is not an entity but rather the table used to generate the SENT. This table is equivalent to <page>scripted_ents.GetStored</page>("ent_name").</warning>\r\n```lua\rply: Player\r\n--The player that is spawning this SENT\r\ntr: table\r\n--A <page>Structures/TraceResult</page> from player eyes to their aim position\r\nClassName: string\r\n--The classname of your entity\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param tr table\n---@param ClassName string'
customsnip = 'Add("SpawnFunction", "${1:name}", function(ply, tr, ClassName)\n\t$0\nend)'

[StartEngineSchedule]
type = 'interface'
description = 'Starts an engine schedule.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rscheduleID: number\r\n--Schedule ID to start. See <page>Enums/SCHED</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param scheduleID number'
customsnip = 'Add("StartEngineSchedule", "${1:name}", function(scheduleID)\n\t$0\nend)'

[StartEngineTask]
type = 'interface'
description = 'Called when an engine task has been started on the entity.\r\n\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rtaskID: number\r\n--Task ID to start, see [ai_task.h](https://github.com/ValveSoftware/source-sdk-2013/blob/55ed12f8d1eb6887d348be03aee5573d44177ffb/mp/src/game/server/ai_task.h#L89-L502)\r\nTaskData: number\r\n--Task data\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param taskID number\n---@param TaskData number'
customsnip = 'Add("StartEngineTask", "${1:name}", function(taskID, TaskData)\n\t$0\nend)'

[StartSchedule]
type = 'interface'
description = 'Starts a schedule previously created by <page>ai_schedule.New</page>.\r\n\r\nNot to be confused with <page>ENTITY:StartEngineSchedule</page> or <page>NPC:SetSchedule</page> which start an Engine-based schedule.\r\n\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rsched: Schedule\r\n--Schedule to start.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param sched Schedule'
customsnip = 'Add("StartSchedule", "${1:name}", function(sched)\n\t$0\nend)'

[StartTask]
type = 'interface'
description = 'Called once on starting task.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n```lua\rtask: Task\r\n--The task to start, created by <page>ai_task.New</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param task Task'
customsnip = 'Add("StartTask", "${1:name}", function(task)\n\t$0\nend)'

[StartTouch]
type = 'interface'
description = 'Called when the entity starts touching another entity.\r\n\r\n<warning>This only works for **brush** entities and for entities that have <page>Entity:SetTrigger</page> set to true.</warning>\r\n```lua\rentity: Entity\r\n--The entity which is being touched.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param entity Entity'
customsnip = 'Add("StartTouch", "${1:name}", function(entity)\n\t$0\nend)'

[StoreOutput]
type = 'interface'
description = 'Used to store an output so it can be triggered with <page>ENTITY:TriggerOutput</page>.\r\nOutputs compiled into a map are passed to entities as key/value pairs through <page>ENTITY:KeyValue</page>.\r\n\r\nTriggerOutput will do nothing if this function has not been called first.\r\n```lua\rname: string\r\n--Name of output to store\r\ninfo: string\r\n--Output info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param name string\n---@param info string'
customsnip = 'Add("StoreOutput", "${1:name}", function(name, info)\n\t$0\nend)'

[TaskFinished]
type = 'interface'
description = 'Returns true if the current running Task is finished.\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("TaskFinished", "${1:name}", function()\n\t$0\nend)'

[TaskTime]
type = 'interface'
description = 'Returns how many seconds we\'ve been doing this current task\r\n<note>This hook only exists for **ai** type SENTs</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("TaskTime", "${1:name}", function()\n\t$0\nend)'

[TestCollision]
type = 'interface'
description = 'Allows you to override trace result when a trace hits the entitys Bounding Box.\r\n\r\n<note>Your entity must have <page>Entity:EnableCustomCollisions</page> enabled for this hook to work</note>\r\n<note>This hook is called for `anim` type only</note>\r\n```lua\rstartpos: Vector\r\n--Start position of the trace\r\ndelta: Vector\r\n--Offset from startpos to the endpos of the trace\r\nisbox: boolean\r\n--Is the trace a hull trace?\r\nextents: Vector\r\n--Size of the hull trace?\r\nmask: number\r\n--The <page>Enums/CONTENTS</page> mask\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param startpos Vector\n---@param delta Vector\n---@param isbox boolean\n---@param extents Vector\n---@param mask number'
customsnip = 'Add("TestCollision", "${1:name}", function(startpos, delta, isbox, extents, mask)\n\t$0\nend)'

[Think]
type = 'interface'
description = 'Called every frame on the client.\r\nCalled every tick on the server.\r\n\r\n<note>You may need to call <page>Entity:Spawn</page> to get this hook to run server side.</note>\r\n<note>By default, it runs about 5-6 times per second on the server, but you can force it to run at servers tickrate using the example below.</note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Think", "${1:name}", function()\n\t$0\nend)'

[Touch]
type = 'interface'
description = 'Called every tick for every entity being "touched".\r\n\r\nSee also <page>ENTITY:StartTouch</page> and <page>ENTITY:EndTouch</page>.\r\n\r\n<note>For physics enabled entities, this hook will **not** be ran while the entity\'s physics is asleep. See <page>PhysObj:Wake</page>.</note>\r\n```lua\rentity: Entity\r\n--The entity that touched it.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param entity Entity'
customsnip = 'Add("Touch", "${1:name}", function(entity)\n\t$0\nend)'

[TriggerOutput]
type = 'interface'
description = 'Triggers all outputs stored using <page>ENTITY:StoreOutput</page>.\r\n```lua\routput: string\r\n--Name of output to fire\r\nactivator: Entity\r\n--Activator entity\r\ndata: string\r\n--The data to give to the output.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param output string\n---@param activator Entity\n---@param data string'
customsnip = 'Add("TriggerOutput", "${1:name}", function(output, activator, data)\n\t$0\nend)'

[UpdateTransmitState]
type = 'interface'
description = 'Called whenever the transmit state should be updated.\r\n\r\n**Scope:** Server'
customsnip = 'Add("UpdateTransmitState", "${1:name}", function()\n\t$0\nend)'

[Use]
type = 'interface'
description = 'Called when an entity "uses" this entity, for example a player pressing their `+use` key (default <key>E</key>) on this entity.\r\n\r\nTo change how often the hook is called, see <page>Entity:SetUseType</page>.\r\n\r\n<note>This hook only works for `nextbot`, `ai` and `anim` scripted entity types.</note>\r\n```lua\ractivator: Entity\r\n--The entity that caused this input. This will usually be the player who pressed their use key\r\ncaller: Entity\r\n--The entity responsible for the input. This will typically be the same as `activator` unless some other entity is acting as a proxy\r\nuseType: number\r\n--Use type, see <page>Enums/USE</page>.\r\nvalue: number\r\n--Any passed value.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param activator Entity\n---@param caller Entity\n---@param useType number\n---@param value number'
customsnip = 'Add("Use", "${1:name}", function(activator, caller, useType, value)\n\t$0\nend)'

[AcceptInput]
type = 'interface'
description = 'Called when a map I/O event occurs.\r\n\r\nSee also <page>Entity:Fire</page> and <page>Entity:Input</page> for functions to fire Inputs on entities.\r\n```lua\rent: Entity\r\n--Entity that receives the input\r\ninput: string\r\n--The input name. Is not guaranteed to be a valid input on the entity.\r\nactivator: Entity\r\n--Activator of the input\r\ncaller: Entity\r\n--Caller of the input\r\nvalue: any\r\n--Data provided with the input. Will be either a <page>string</page>, a <page>number</page>, a <page>boolean</page> or a <page>nil</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity\n---@param input string\n---@param activator Entity\n---@param caller Entity\n---@param value any'
customsnip = 'Add("AcceptInput", "${1:name}", function(ent, input, activator, caller, value)\n\t$0\nend)'

[AddDeathNotice]
type = 'interface'
description = 'Adds a death notice entry.\r\n\r\n<bug issue="2611" pull="1380">You cannot use <page>hook.Add</page> on this hook yet.</bug>\r\n```lua\rattacker: string\r\n--The name of the attacker\r\nattackerTeam: number\r\n--The team of the attacker\r\ninflictor: string\r\n--Class name of the entity inflicting the damage\r\nvictim: string\r\n--Name of the victim\r\nvictimTeam: number\r\n--Team of the victim\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param attacker string\n---@param attackerTeam number\n---@param inflictor string\n---@param victim string\n---@param victimTeam number'
customsnip = 'Add("AddDeathNotice", "${1:name}", function(attacker, attackerTeam, inflictor, victim, victimTeam)\n\t$0\nend)'

[AdjustMouseSensitivity]
type = 'interface'
description = 'Allows you to adjust the mouse sensitivity.\r\n```lua\rdefaultSensitivity: number\r\n--The old sensitivity\r\n\r\nIn general it will be 0, which is equivalent to a sensitivity of 1.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param defaultSensitivity number'
customsnip = 'Add("AdjustMouseSensitivity", "${1:name}", function(defaultSensitivity)\n\t$0\nend)'

[AllowPlayerPickup]
type = 'interface'
description = 'Called when a player tries to pick up something using the "use" key, return to override.\r\n\r\nSee <page>GM:GravGunPickupAllowed</page> for the Gravity Gun pickup variant.\r\n```lua\rply: Player\r\n--The player trying to pick up something.\r\nent: Entity\r\n--The Entity the player attempted to pick up.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("AllowPlayerPickup", "${1:name}", function(ply, ent)\n\t$0\nend)'

[CalcMainActivity]
type = 'interface'
description = 'This hook is used to calculate animations for a player.\r\n\r\n<warning>This hook must return the same values at the same time on both, client **and** server. On client for players to see the animations, on server for hit detection to work properly.</warning>\r\n<bug issue="3322">This can return the incorrect velocity when on a moving object.</bug>\r\n```lua\rply: Player\r\n--The player to apply the animation.\r\nvel: Vector\r\n--The velocity of the player.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param vel Vector'
customsnip = 'Add("CalcMainActivity", "${1:name}", function(ply, vel)\n\t$0\nend)'

[CalcVehicleView]
type = 'interface'
description = 'Called from <page>GM:CalcView</page> when player is in driving a vehicle.\r\n\r\nThis hook may not be called in gamemodes that override <page>GM:CalcView</page>.\r\n```lua\rveh: Vehicle\r\n--The vehicle the player is driving\r\nply: Player\r\n--The vehicle driver\r\nview: table\r\n--The view data containing players FOV, view position and angles, see <page>Structures/CamData</page>\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param veh Vehicle\n---@param ply Player\n---@param view table'
customsnip = 'Add("CalcVehicleView", "${1:name}", function(veh, ply, view)\n\t$0\nend)'

[CalcView]
type = 'interface'
description = 'Allows override of the default view.\r\n```lua\rply: Player\r\n--The local player.\r\norigin: Vector\r\n--The player\'s view position.\r\nangles: Angle\r\n--The player\'s view angles.\r\nfov: number\r\n--Field of view.\r\nznear: number\r\n--Distance to near clipping plane.\r\nzfar: number\r\n--Distance to far clipping plane.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param origin Vector\n---@param angles Angle\n---@param fov number\n---@param znear number\n---@param zfar number'
customsnip = 'Add("CalcView", "${1:name}", function(ply, origin, angles, fov, znear, zfar)\n\t$0\nend)'

[CalcViewModelView]
type = 'interface'
description = 'Allows overriding the position and angle of the viewmodel.\r\n```lua\rwep: Weapon\r\n--The weapon entity\r\nvm: Entity\r\n--The viewmodel entity\r\noldPos: Vector\r\n--Original position (before viewmodel bobbing and swaying)\r\noldAng: Angle\r\n--Original angle (before viewmodel bobbing and swaying)\r\npos: Vector\r\n--Current position\r\nang: Angle\r\n--Current angle\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param wep Weapon\n---@param vm Entity\n---@param oldPos Vector\n---@param oldAng Angle\n---@param pos Vector\n---@param ang Angle'
customsnip = 'Add("CalcViewModelView", "${1:name}", function(wep, vm, oldPos, oldAng, pos, ang)\n\t$0\nend)'

[CanEditVariable]
type = 'interface'
description = 'Called when a variable is edited on an Entity (called by `Edit Properties...` menu), to determine if the edit should be permitted.\r\n\r\nSee <page text="Editable entities">Editable_Entities</page> for more details about the system.\r\n```lua\rent: Entity\r\n--The entity being edited.\r\nply: Player\r\n--The player doing the editing.\r\nkey: string\r\n--The name of the variable.\r\nval: string\r\n--The new value, as a string which will later be converted to its appropriate type.\r\neditor: table\r\n--The edit table defined in <page>Entity:NetworkVar</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity\n---@param ply Player\n---@param key string\n---@param val string\n---@param editor table'
customsnip = 'Add("CanEditVariable", "${1:name}", function(ent, ply, key, val, editor)\n\t$0\nend)'

[CanExitVehicle]
type = 'interface'
description = 'Determines if the player can exit the vehicle.\r\n```lua\rveh: Vehicle\r\n--The vehicle entity\r\nply: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param veh Vehicle\n---@param ply Player'
customsnip = 'Add("CanExitVehicle", "${1:name}", function(veh, ply)\n\t$0\nend)'

[CanPlayerEnterVehicle]
type = 'interface'
description = 'Determines whether or not the player can enter the vehicle.\r\n\r\nCalled just before <page>GM:PlayerEnteredVehicle</page>.\r\n```lua\rplayer: Player\r\n--The player\r\nvehicle: Vehicle\r\n--The vehicle\r\nrole: number\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param player Player\n---@param vehicle Vehicle\n---@param role number'
customsnip = 'Add("CanPlayerEnterVehicle", "${1:name}", function(player, vehicle, role)\n\t$0\nend)'

[CanPlayerSuicide]
type = 'interface'
description = 'Determines if the player can kill themselves using the concommands `kill` or `explode`.\r\n```lua\rplayer: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param player Player'
customsnip = 'Add("CanPlayerSuicide", "${1:name}", function(player)\n\t$0\nend)'

[CanPlayerUnfreeze]
type = 'interface'
description = 'Determines if the player can unfreeze the entity.\r\n```lua\rplayer: Player\r\n--The player\r\nentity: Entity\r\n--The entity\r\nphys: PhysObj\r\n--The physics object of the entity\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param player Player\n---@param entity Entity\n---@param phys PhysObj'
customsnip = 'Add("CanPlayerUnfreeze", "${1:name}", function(player, entity, phys)\n\t$0\nend)'

[CanUndo]
type = 'interface'
description = 'Called whenever a players tries to undo.\r\n```lua\rply: Player\r\n--The player who tried to undo something.\r\nundo: table\r\n--The undo table as a <page>Structures/Undo</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param undo table'
customsnip = 'Add("CanUndo", "${1:name}", function(ply, undo)\n\t$0\nend)'

[CaptureVideo]
type = 'interface'
description = 'Called each frame to record demos to video using <page>IVideoWriter</page>.\r\n\r\n<note>This hook is called every frame regardless of whether or not a demo is being recorded</note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("CaptureVideo", "${1:name}", function()\n\t$0\nend)'

[ChatText]
type = 'interface'
description = 'Called when a message is printed to the chat box. Note, that this isn\'t working with player messages even though there are arguments for it.\r\n\r\nFor player messages see <page>GM:PlayerSay</page> and <page>GM:OnPlayerChat</page>\r\n```lua\rindex: number\r\n--The index of the player.\r\nname: string\r\n--The name of the player.\r\ntext: string\r\n--The text that is being sent.\r\ntype: string\r\n--Chat filter type. Possible values are:\r\n* `joinleave` - Player join and leave messages\r\n* `namechange` - Player name change messages\r\n* `servermsg` - Server messages such as convar changes\r\n* `teamchange` - Team changes?\r\n* `chat` - (Obsolete?) Player chat?\r\n* `none` - A fallback value\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param index number\n---@param name string\n---@param text string\n---@param type string'
customsnip = 'Add("ChatText", "${1:name}", function(index, name, text, type)\n\t$0\nend)'

[ChatTextChanged]
type = 'interface'
description = 'Called whenever the content of the user\'s chat input box is changed.\r\n```lua\rtext: string\r\n--The new contents of the input box\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param text string'
customsnip = 'Add("ChatTextChanged", "${1:name}", function(text)\n\t$0\nend)'

[CheckPassword]
type = 'interface'
description = 'Called when a non local player connects to allow the Lua system to check the password.\r\n\r\nThe default behaviour in the base gamemodes emulates what would normally happen. If sv_password is set and its value matches the password passed in by the client - then they are allowed to join. If it isn\'t set it lets them in too.\r\n```lua\rsteamID64: string\r\n--The 64bit Steam ID of the joining player, use <page>util.SteamIDFrom64</page> to convert it to a `STEAM_0:` one.\r\nipAddress: string\r\n--The IP of the connecting client\r\nsvPassword: string\r\n--The current value of sv_password (the password set by the server)\r\nclPassword: string\r\n--The password provided by the client\r\nname: string\r\n--The name of the joining player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param steamID64 string\n---@param ipAddress string\n---@param svPassword string\n---@param clPassword string\n---@param name string'
customsnip = 'Add("CheckPassword", "${1:name}", function(steamID64, ipAddress, svPassword, clPassword, name)\n\t$0\nend)'

[CloseDermaMenus]
type = 'interface'
description = 'Called when derma menus are closed with <page>Global.CloseDermaMenus</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("CloseDermaMenus", "${1:name}", function()\n\t$0\nend)'

[CreateClientsideRagdoll]
type = 'interface'
description = 'Called whenever an entity becomes a clientside ragdoll.\r\n\r\nSee <page>GM:CreateEntityRagdoll</page> for serverside ragdolls.\r\n```lua\rentity: Entity\r\n--The Entity that created the ragdoll\r\nragdoll: Entity\r\n--The ragdoll being created.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param entity Entity\n---@param ragdoll Entity'
customsnip = 'Add("CreateClientsideRagdoll", "${1:name}", function(entity, ragdoll)\n\t$0\nend)'

[CreateEntityRagdoll]
type = 'interface'
description = 'Called when a serverside ragdoll of an entity has been created.\r\n\r\nSee <page>GM:CreateClientsideRagdoll</page> for clientside ragdolls.\r\n```lua\rowner: Entity\r\n--Entity that owns the ragdoll\r\nragdoll: Entity\r\n--The ragdoll entity\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param owner Entity\n---@param ragdoll Entity'
customsnip = 'Add("CreateEntityRagdoll", "${1:name}", function(owner, ragdoll)\n\t$0\nend)'

[CreateMove]
type = 'interface'
description = 'Allows you to change the players movements before they\'re sent to the server.\r\n\r\nSee <page>Game Movement</page> for an explanation on the move system.\r\n\r\n<note>Due to this hook being clientside only, it could be overridden by the user allowing them to completely skip your logic, it is recommended to use <page>GM:StartCommand</page> in a shared file instead.</note>\r\n```lua\rcmd: CUserCmd\r\n--The User Command data\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param cmd CUserCmd'
customsnip = 'Add("CreateMove", "${1:name}", function(cmd)\n\t$0\nend)'

[CreateTeams]
type = 'interface'
description = 'Teams are created within this hook using <page>team.SetUp</page>.\r\n\r\n<note>This hook is called before <page>GM:PreGamemodeLoaded</page>.</note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("CreateTeams", "${1:name}", function()\n\t$0\nend)'

[DoAnimationEvent]
type = 'interface'
description = 'Called upon an animation event, this is the ideal place to call player animation functions such as <page>Player:AddVCDSequenceToGestureSlot</page>, <page>Player:AnimRestartGesture</page> and so on.\r\n```lua\rply: Player\r\n--Player who is being animated\r\nevent: number\r\n--Animation event. See <page>Enums/PLAYERANIMEVENT</page>\r\ndata: number\r\n--The data for the event. This is interpreted as an <page>Enums/ACT</page> by `PLAYERANIMEVENT_CUSTOM` and `PLAYERANIMEVENT_CUSTOM_GESTURE`, or a sequence by `PLAYERANIMEVENT_CUSTOM_SEQUENCE`.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param event number\n---@param data number'
customsnip = 'Add("DoAnimationEvent", "${1:name}", function(ply, event, data)\n\t$0\nend)'

[DoPlayerDeath]
type = 'interface'
description = 'Handles the player\'s death.\r\n\r\nThis hook is **not** called if the player is killed by <page>Player:KillSilent</page>. See <page>GM:PlayerSilentDeath</page> for that.\r\n\r\n* <page>GM:PlayerDeath</page> is called after this hook\r\n* <page>GM:PostPlayerDeath</page> is called after that\r\n<note><page>Player:Alive</page> returns true when this is called</note>\r\n```lua\rply: Player\r\n--The player\r\nattacker: Entity\r\n--The entity that killed the player\r\ndmg: CTakeDamageInfo\r\n--Damage info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param attacker Entity\n---@param dmg CTakeDamageInfo'
customsnip = 'Add("DoPlayerDeath", "${1:name}", function(ply, attacker, dmg)\n\t$0\nend)'

[DrawDeathNotice]
type = 'interface'
description = 'This hook is called every frame to draw all of the current death notices.\r\n```lua\rx: number\r\n--X position to draw death notices as a ratio\r\ny: number\r\n--Y position to draw death notices as a ratio\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param x number\n---@param y number'
customsnip = 'Add("DrawDeathNotice", "${1:name}", function(x, y)\n\t$0\nend)'

[DrawMonitors]
type = 'interface'
description = 'Called every frame before drawing the in-game monitors ( Breencast, in-game TVs, etc ), but doesn\'t seem to be doing anything, trying to render 2D or 3D elements fail.\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawMonitors", "${1:name}", function()\n\t$0\nend)'

[DrawOverlay]
type = 'interface'
description = 'Called after all other 2D draw hooks are called. Draws over all VGUI Panels and HUDs.\r\n\r\nUnlike <page>GM:HUDPaint</page>, this hook is called with the game paused and while the Camera SWEP is equipped.\r\n\r\n<note>Only gets called when r_drawvgui is enabled.</note>\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawOverlay", "${1:name}", function()\n\t$0\nend)'

[DrawPhysgunBeam]
type = 'interface'
description = 'Allows you to override physgun beam drawing.\r\n\r\n<bug issue="3294">This is still called when physgun_drawbeams is disabled.</bug>\r\n```lua\rply: Player\r\n--Physgun owner\r\nphysgun: Weapon\r\n--The physgun\r\nenabled: boolean\r\n--Is the beam enabled\r\ntarget: Entity\r\n--Entity we are grabbing. This will be NULL if nothing is being held\r\nphysBone: number\r\n--ID of the physics bone (<page>PhysObj</page>) we are grabbing at. Use <page>Entity:TranslatePhysBoneToBone</page> to translate to an actual bone.\r\nhitPos: Vector\r\n--Beam hit position relative to the physics bone (<page>PhysObj</page>) we are grabbing.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param physgun Weapon\n---@param enabled boolean\n---@param target Entity\n---@param physBone number\n---@param hitPos Vector'
customsnip = 'Add("DrawPhysgunBeam", "${1:name}", function(ply, physgun, enabled, target, physBone, hitPos)\n\t$0\nend)'

[EndEntityDriving]
type = 'interface'
description = 'Called right before an entity stops driving. Overriding this hook will cause it to not call <page>drive.End</page> and the player will not stop driving.\r\n```lua\rent: Entity\r\n--The entity being driven\r\nply: Player\r\n--The player driving the entity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity\n---@param ply Player'
customsnip = 'Add("EndEntityDriving", "${1:name}", function(ent, ply)\n\t$0\nend)'

[EntityEmitSound]
type = 'interface'
description = 'Called whenever a sound has been played. This will not be called clientside if the server played the sound without the client also calling <page>Entity:EmitSound</page>.\r\n\r\n<bug issue="1021">This is not called for scripted sequences.</bug>\r\n```lua\rdata: table\r\n--Information about the played sound. Changes done to this table can be applied by returning true from this hook.\r\n\r\nSee <page>Structures/EmitSoundInfo</page>.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param data table'
customsnip = 'Add("EntityEmitSound", "${1:name}", function(data)\n\t$0\nend)'

[EntityFireBullets]
type = 'interface'
description = 'Called every time a bullet is fired from an entity.\r\n\r\n<warning>This hook is called directly from <page>Entity:FireBullets</page>. Due to this, you cannot call <page>Entity:FireBullets</page> inside this hook or an infinite loop will occur crashing the game.</warning>\r\n```lua\rent: Entity\r\n--The entity that fired the bullet\r\ndata: table\r\n--The bullet data. See <page>Structures/Bullet</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity\n---@param data table'
customsnip = 'Add("EntityFireBullets", "${1:name}", function(ent, data)\n\t$0\nend)'

[EntityKeyValue]
type = 'interface'
description = 'Called when a key-value pair is set on an entity, either by the engine (for example when map spawns) or <page>Entity:SetKeyValue</page>.\r\n\r\nSee <page>ENTITY:KeyValue</page> for a hook that works for scripted entities.\r\n\r\n\r\nSee <page>WEAPON:KeyValue</page> for a hook that works for scripted weapons.\r\n```lua\rent: Entity\r\n--Entity that the keyvalue is being set on\r\nkey: string\r\n--Key of the key/value pair\r\nvalue: string\r\n--Value of the key/value pair\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity\n---@param key string\n---@param value string'
customsnip = 'Add("EntityKeyValue", "${1:name}", function(ent, key, value)\n\t$0\nend)'

[EntityNetworkedVarChanged]
type = 'interface'
description = 'Called when an NWVar is changed.\r\n\r\n<note>Currently this hook only works for the NW2Var system (accessed by adding a 2 in between NW and Var for most NWVar functions), which will replace the original one at some point in the future</note>\r\n<note>This hook is fired before the client value is actually changed. Calling the GetNW function for the specified variable name within this hook will return the old value, not the current/updated one.</note>\r\n```lua\rent: Entity\r\n--The owner entity of changed NWVar\r\nname: string\r\n--The name if changed NWVar\r\noldval: any\r\n--The old value of the NWVar\r\nnewval: any\r\n--The new value of the NWVar\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity\n---@param name string\n---@param oldval any\n---@param newval any'
customsnip = 'Add("EntityNetworkedVarChanged", "${1:name}", function(ent, name, oldval, newval)\n\t$0\nend)'

[EntityRemoved]
type = 'interface'
description = 'Called right before the removal of an entity.\r\n```lua\rent: Entity\r\n--Entity being removed\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity'
customsnip = 'Add("EntityRemoved", "${1:name}", function(ent)\n\t$0\nend)'

[EntityTakeDamage]
type = 'interface'
description = 'Called when an entity takes damage. You can modify all parts of the damage info in this hook.\r\n```lua\rtarget: Entity\r\n--The entity taking damage\r\ndmg: CTakeDamageInfo\r\n--Damage info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param target Entity\n---@param dmg CTakeDamageInfo'
customsnip = 'Add("EntityTakeDamage", "${1:name}", function(target, dmg)\n\t$0\nend)'

[FindUseEntity]
type = 'interface'
description = 'This hook polls the entity the player use action should be applied to.\r\n\r\n<note>The default behavior of this hook is in [CBasePlayer::FindUseEntity](https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/game/shared/baseplayer_shared.cpp#L1068-L1270). Despite CBasePlayer::FindUseEntity being defined shared, it is only called serverside in practice, so this hook will be only called serverside, as well. It is possible for modules to call it clientside, so the Lua code should still be treated as shared.</note>\r\n```lua\rply: Player\r\n--The player who initiated the use action.\r\ndefaultEnt: Entity\r\n--The entity that was chosen by the engine.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param defaultEnt Entity'
customsnip = 'Add("FindUseEntity", "${1:name}", function(ply, defaultEnt)\n\t$0\nend)'

[FinishChat]
type = 'interface'
description = 'Runs when user cancels/finishes typing.\r\n\r\n**Scope:** Client'
customsnip = 'Add("FinishChat", "${1:name}", function()\n\t$0\nend)'

[FinishMove]
type = 'interface'
description = 'Called after <page>GM:Move</page>, applies all the changes from the <page>CMoveData</page> to the player.\r\n\r\nSee <page>Game Movement</page> for an explanation on the move system.\r\n```lua\rply: Player\r\n--Player\r\nmv: CMoveData\r\n--Movement data\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param mv CMoveData'
customsnip = 'Add("FinishMove", "${1:name}", function(ply, mv)\n\t$0\nend)'

[ForceDermaSkin]
type = 'interface'
description = 'Called to allow override of the default Derma skin for all panels.\r\n\r\n<note>This hook is only called on Lua start up, changing its value (or adding new hooks) after it has been already called will not have any effect.</note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("ForceDermaSkin", "${1:name}", function()\n\t$0\nend)'

[GameContentChanged]
type = 'interface'
description = 'Called to refresh menu content once it has initialized or something has been mounted.\r\n\r\n**Scope:** Client'
customsnip = 'Add("GameContentChanged", "${1:name}", function()\n\t$0\nend)'

[GetFallDamage]
type = 'interface'
description = 'Called when a player takes damage from falling, allows to override the damage.\r\n```lua\rply: Player\r\n--The player\r\nspeed: number\r\n--The fall speed\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param speed number'
customsnip = 'Add("GetFallDamage", "${1:name}", function(ply, speed)\n\t$0\nend)'

[GetGameDescription]
type = 'interface'
description = 'Called when the game(server) needs to update the text shown in the server browser as the gamemode.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("GetGameDescription", "${1:name}", function()\n\t$0\nend)'

[GetMotionBlurValues]
type = 'interface'
description = 'Allows you to modify the Source Engine\'s motion blur shaders.\r\n```lua\rhorizontal: number\r\n--The amount of horizontal blur.\r\nvertical: number\r\n--The amount of vertical  blur.\r\nforward: number\r\n--The amount of forward/radial blur.\r\nrotational: number\r\n--The amount of rotational blur.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param horizontal number\n---@param vertical number\n---@param forward number\n---@param rotational number'
customsnip = 'Add("GetMotionBlurValues", "${1:name}", function(horizontal, vertical, forward, rotational)\n\t$0\nend)'

[GetPreferredCarryAngles]
type = 'interface'
description = 'Called to determine preferred carry angles for the entity. It works for both, +use pickup and gravity gun pickup.\r\n\r\n<warning>Due to nature of the gravity gun coding in multiplayer, this hook **MAY** seem to not work ( but rest assured it does ), due to clientside prediction not knowing the carry angles. The +use pickup doesn\'t present this issue as it doesn\'t predict the player carrying the object clientside ( as you may notice by the prop lagging behind in multiplayer )</warning>\r\n\r\n<note>This hook can **not** override preferred carry angles of props such as the sawblade and the harpoon.</note>\r\n```lua\rent: Entity\r\n--The entity to generate carry angles for\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("GetPreferredCarryAngles", "${1:name}", function(ent)\n\t$0\nend)'

[GetTeamColor]
type = 'interface'
description = 'Returns the color for the given entity\'s team. This is used in chat and deathnotice text.\r\n```lua\rent: Entity\r\n--Entity\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ent Entity'
customsnip = 'Add("GetTeamColor", "${1:name}", function(ent)\n\t$0\nend)'

[GetTeamNumColor]
type = 'interface'
description = 'Returns the team color for the given team index.\r\n```lua\rteam: number\r\n--Team index\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param team number'
customsnip = 'Add("GetTeamNumColor", "${1:name}", function(team)\n\t$0\nend)'

[GrabEarAnimation]
type = 'interface'
description = 'Override this hook to disable/change ear-grabbing in your gamemode.\r\n```lua\rply: Player\r\n--Player\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("GrabEarAnimation", "${1:name}", function(ply)\n\t$0\nend)'

[GravGunOnDropped]
type = 'interface'
description = 'Called when an entity is released by a gravity gun.\r\n```lua\rply: Player\r\n--Player who is wielding the gravity gun\r\nent: Entity\r\n--The entity that has been dropped\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("GravGunOnDropped", "${1:name}", function(ply, ent)\n\t$0\nend)'

[GravGunOnPickedUp]
type = 'interface'
description = 'Called when an entity is picked up by a gravity gun.\r\n```lua\rply: Player\r\n--The player wielding the gravity gun\r\nent: Entity\r\n--The entity that has been picked up by the gravity gun\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("GravGunOnPickedUp", "${1:name}", function(ply, ent)\n\t$0\nend)'

[GravGunPickupAllowed]
type = 'interface'
description = 'Called every tick to poll whether a player is allowed to pick up an entity with the gravity gun or not.\r\n\r\nSee <page>GM:AllowPlayerPickup</page> for the +USE pickup variant.\r\n\r\nCalls <page>ENTITY:GravGunPickupAllowed</page> on the entity being hovered every frame in Sandbox-derived gamemodes.\r\n```lua\rply: Player\r\n--The player wielding the gravity gun\r\nent: Entity\r\n--The entity the player is attempting to pick up\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("GravGunPickupAllowed", "${1:name}", function(ply, ent)\n\t$0\nend)'

[GravGunPunt]
type = 'interface'
description = 'Called when an entity is about to be punted with the gravity gun (primary fire).\r\n\r\nBy default this function makes <page>ENTITY:GravGunPunt</page> work in Sandbox derived gamemodes.\r\n```lua\rply: Player\r\n--The player wielding the gravity gun\r\nent: Entity\r\n--The entity the player is attempting to punt\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("GravGunPunt", "${1:name}", function(ply, ent)\n\t$0\nend)'

[GUIMouseDoublePressed]
type = 'interface'
description = 'Called when the mouse has been double clicked on any panel derived from CGModBase, such as the panel used by <page>gui.EnableScreenClicker</page> and the panel used by <page>Panel:ParentToHUD</page>.\r\n\r\nBy default this hook calls <page>GM:GUIMousePressed</page>.\r\n```lua\rmouseCode: number\r\n--The code of the mouse button pressed, see <page>Enums/MOUSE</page>\r\naimVector: Vector\r\n--A normalized vector pointing in the direction the client has clicked\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param mouseCode number\n---@param aimVector Vector'
customsnip = 'Add("GUIMouseDoublePressed", "${1:name}", function(mouseCode, aimVector)\n\t$0\nend)'

[GUIMousePressed]
type = 'interface'
description = 'Called whenever a players presses a mouse key on the context menu in Sandbox or on any panel derived from CGModBase, such as the panel used by <page>gui.EnableScreenClicker</page> and the panel used by <page>Panel:ParentToHUD</page>.\r\n\r\nSee <page>GM:VGUIMousePressed</page> for a hook that is called on all VGUI elements.\r\n```lua\rmouseCode: number\r\n--The key that the player pressed using <page>Enums/MOUSE</page>.\r\naimVector: Vector\r\n--A normalized direction vector local to the camera. Internally, this is  <page>gui.ScreenToVector</page>( <page>gui.MousePos</page>() ).\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param mouseCode number\n---@param aimVector Vector'
customsnip = 'Add("GUIMousePressed", "${1:name}", function(mouseCode, aimVector)\n\t$0\nend)'

[GUIMouseReleased]
type = 'interface'
description = 'Called whenever a players releases a mouse key on the context menu in Sandbox or on any panel derived from CGModBase, such as the panel used by <page>gui.EnableScreenClicker</page> and the panel used by <page>Panel:ParentToHUD</page>.\r\n```lua\rmouseCode: number\r\n--The key the player released, see <page>Enums/MOUSE</page>\r\naimVector: Vector\r\n--A normalized direction vector local to the camera. Internally this is  <page>gui.ScreenToVector</page>( <page>gui.MousePos</page>() ).\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param mouseCode number\n---@param aimVector Vector'
customsnip = 'Add("GUIMouseReleased", "${1:name}", function(mouseCode, aimVector)\n\t$0\nend)'

[HandlePlayerDriving]
type = 'interface'
description = 'Allows to override player driving animations.\r\n```lua\rply: Player\r\n--Player to process\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("HandlePlayerDriving", "${1:name}", function(ply)\n\t$0\nend)'

[HandlePlayerDucking]
type = 'interface'
description = 'Allows to override player crouch animations.\r\n```lua\rply: Player\r\n--The player\r\nvelocity: number\r\n--Players velocity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity number'
customsnip = 'Add("HandlePlayerDucking", "${1:name}", function(ply, velocity)\n\t$0\nend)'

[HandlePlayerJumping]
type = 'interface'
description = 'Called every frame by the player model animation system. Allows to override player jumping animations.\r\n```lua\rply: Player\r\n--The player\r\nvelocity: number\r\n--Players velocity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity number'
customsnip = 'Add("HandlePlayerJumping", "${1:name}", function(ply, velocity)\n\t$0\nend)'

[HandlePlayerLanding]
type = 'interface'
description = 'Allows to override player landing animations.\r\n```lua\rply: Player\r\n--The player\r\nvelocity: number\r\n--Players velocity\r\nonGround: boolean\r\n--Was the player on ground?\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity number\n---@param onGround boolean'
customsnip = 'Add("HandlePlayerLanding", "${1:name}", function(ply, velocity, onGround)\n\t$0\nend)'

[HandlePlayerNoClipping]
type = 'interface'
description = 'Allows to override player noclip animations.\r\n```lua\rply: Player\r\n--The player\r\nvelocity: number\r\n--Players velocity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity number'
customsnip = 'Add("HandlePlayerNoClipping", "${1:name}", function(ply, velocity)\n\t$0\nend)'

[HandlePlayerSwimming]
type = 'interface'
description = 'Allows to override player swimming animations.\r\n```lua\rply: Player\r\n--The player\r\nvelocity: number\r\n--Players velocity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity number'
customsnip = 'Add("HandlePlayerSwimming", "${1:name}", function(ply, velocity)\n\t$0\nend)'

[HandlePlayerVaulting]
type = 'interface'
description = 'Allows to override player flying ( in mid-air, not noclipping ) animations.\r\n```lua\rply: Player\r\n--The player\r\nvelocity: number\r\n--Players velocity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity number'
customsnip = 'Add("HandlePlayerVaulting", "${1:name}", function(ply, velocity)\n\t$0\nend)'

[HideTeam]
type = 'interface'
description = 'Hides the team selection panel.\r\n\r\n**Scope:** Client'
customsnip = 'Add("HideTeam", "${1:name}", function()\n\t$0\nend)'

[HUDAmmoPickedUp]
type = 'interface'
description = 'Called when the client has picked up ammo. Override to disable default HUD notification.\r\n```lua\ritemName: string\r\n--Name of the item (ammo) picked up\r\namount: number\r\n--Amount of the item (ammo) picked up\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param itemName string\n---@param amount number'
customsnip = 'Add("HUDAmmoPickedUp", "${1:name}", function(itemName, amount)\n\t$0\nend)'

[HUDDrawPickupHistory]
type = 'interface'
description = 'Renders the HUD pick-up history. Override to hide default or draw your own HUD.\r\n\r\n**Scope:** Client'
customsnip = 'Add("HUDDrawPickupHistory", "${1:name}", function()\n\t$0\nend)'

[HUDDrawScoreBoard]
type = 'interface'
description = 'Called every frame to render the scoreboard.\r\n\r\n\r\nIt is recommended to use Derma and VGUI for this job instead of this hook. Called right after <page>GM:HUDPaint</page>.\r\n\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("HUDDrawScoreBoard", "${1:name}", function()\n\t$0\nend)'

[HUDDrawTargetID]
type = 'interface'
description = 'Called from <page>GM:HUDPaint</page> to draw player info when you hover over a player with your crosshair or mouse.\r\n\r\n**Scope:** Client'
customsnip = 'Add("HUDDrawTargetID", "${1:name}", function()\n\t$0\nend)'

[HUDItemPickedUp]
type = 'interface'
description = 'Called when an item has been picked up. Override to disable the default HUD notification.\r\n```lua\ritemName: string\r\n--Name of the picked up item\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param itemName string'
customsnip = 'Add("HUDItemPickedUp", "${1:name}", function(itemName)\n\t$0\nend)'

[HUDPaint]
type = 'interface'
description = 'Called whenever the HUD should be drawn. Called right before <page>GM:HUDDrawScoreBoard</page> and after <page>GM:HUDPaintBackground</page>.\r\n\r\nNot called when the Camera SWEP is equipped. See also <page>GM:DrawOverlay</page>.\r\n\r\n<note>Gets called only when r_drawvgui and <page text="CHudGMod">GM:HUDShouldDraw</page> are enabled and the game is not paused</note>\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("HUDPaint", "${1:name}", function()\n\t$0\nend)'

[HUDPaintBackground]
type = 'interface'
description = 'Called before <page>GM:HUDPaint</page> when the HUD background is being drawn.\r\n\r\n\r\nThings rendered in this hook will **always** appear behind things rendered in <page>GM:HUDPaint</page>.\r\n\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("HUDPaintBackground", "${1:name}", function()\n\t$0\nend)'

[HUDShouldDraw]
type = 'interface'
description = 'Called when the Gamemode is about to draw a given element on the client\'s HUD (heads-up display).\r\n\r\n<warning>This hook is called HUNDREDS of times per second (more than 5 times per frame on average). You shouldn\'t be performing any computationally intensive operations.</warning>\r\n```lua\rname: string\r\n--The name of the HUD element. You can find a full list of HUD elements for this hook <page text="here">HUD_Element_List</page>.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param name string'
customsnip = 'Add("HUDShouldDraw", "${1:name}", function(name)\n\t$0\nend)'

[HUDWeaponPickedUp]
type = 'interface'
description = 'Called when a weapon has been picked up. Override to disable the default HUD notification.\r\n```lua\rweapon: Weapon\r\n--The picked up weapon\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param weapon Weapon'
customsnip = 'Add("HUDWeaponPickedUp", "${1:name}", function(weapon)\n\t$0\nend)'

[Initialize]
type = 'interface'
description = 'Called after the gamemode loads and starts.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Initialize", "${1:name}", function()\n\t$0\nend)'

[InitPostEntity]
type = 'interface'
description = 'Called after all the entities are initialized. Starting from this hook <page>Global.LocalPlayer</page> will return valid object.\r\n\r\n<note>At this point the client only knows about the entities that are within the spawnpoints\' [PVS](https://en.wikipedia.org/wiki/Potentially_visible_set). For instance, if the server sends an entity that is not within this PVS, the client will receive it as NULL entity.</note>\r\n<note>When this hook is called on the client, <page>net</page> messages will reliably be received.</note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("InitPostEntity", "${1:name}", function()\n\t$0\nend)'

[InputMouseApply]
type = 'interface'
description = 'Allows you to modify the supplied User Command with mouse input. This could be used to make moving the mouse do funky things to view angles.\r\n```lua\rcmd: CUserCmd\r\n--User command.\r\nx: number\r\n--The amount of mouse movement across the X axis this frame.\r\ny: number\r\n--The amount of mouse movement across the Y axis this frame.\r\nang: Angle\r\n--The current view angle.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param cmd CUserCmd\n---@param x number\n---@param y number\n---@param ang Angle'
customsnip = 'Add("InputMouseApply", "${1:name}", function(cmd, x, y, ang)\n\t$0\nend)'

[IsSpawnpointSuitable]
type = 'interface'
description = 'Check if a player can spawn at a certain spawnpoint.\r\n```lua\rply: Player\r\n--The player who is spawned\r\nspawnpoint: Entity\r\n--The spawnpoint entity (on the map).\r\nmakeSuitable: boolean\r\n--If this is true, it\'ll kill any players blocking the spawnpoint.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param spawnpoint Entity\n---@param makeSuitable boolean'
customsnip = 'Add("IsSpawnpointSuitable", "${1:name}", function(ply, spawnpoint, makeSuitable)\n\t$0\nend)'

[KeyPress]
type = 'interface'
description = 'Called whenever a player pressed a key included within the IN keys.\r\n\r\nFor a more general purpose function that handles all kinds of input, see <page>GM:PlayerButtonDown</page>.\r\n\r\n<warning>Due to this being a predicted hook, <page>Global.ParticleEffect</page>s created only serverside from this hook will not be networked to the client, so make sure to do that on both realms.</warning>\r\n```lua\rply: Player\r\n--The player pressing the key. If running client-side, this will always be <page>Global.LocalPlayer</page>.\r\nkey: number\r\n--The key that the player pressed using <page>Enums/IN</page>.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param key number'
customsnip = 'Add("KeyPress", "${1:name}", function(ply, key)\n\t$0\nend)'

[KeyRelease]
type = 'interface'
description = 'Runs when a IN key was released by a player.\r\n\r\nFor a more general purpose function that handles all kinds of input, see <page>GM:PlayerButtonUp</page>.\r\n```lua\rply: Player\r\n--The player releasing the key. If running client-side, this will always be <page>Global.LocalPlayer</page>.\r\nkey: number\r\n--The key that the player released using <page>Enums/IN</page>.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param key number'
customsnip = 'Add("KeyRelease", "${1:name}", function(ply, key)\n\t$0\nend)'

[LoadGModSave]
type = 'interface'
description = '<internal></internal>Called from gm_load when the game should load a map.\r\n```lua\rdata: string\r\n--Compressed save data\r\nmap: string\r\n--The name of the map the save was created on\r\ntimestamp: number\r\n--The time the save was created on. Will always be 0.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param data string\n---@param map string\n---@param timestamp number'
customsnip = 'Add("LoadGModSave", "${1:name}", function(data, map, timestamp)\n\t$0\nend)'

[MenuStart]
type = 'interface'
description = 'Called when `menu.lua` has finished loading.\r\n\r\n**Scope:** Client'
customsnip = 'Add("MenuStart", "${1:name}", function()\n\t$0\nend)'

[MouthMoveAnimation]
type = 'interface'
description = 'Override this gamemode function to disable mouth movement when talking on voice chat.\r\n```lua\rply: Player\r\n--Player in question\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("MouthMoveAnimation", "${1:name}", function(ply)\n\t$0\nend)'

[Move]
type = 'interface'
description = 'The Move hook is called for you to manipulate the player\'s MoveData.\r\n\r\nYou shouldn\'t adjust the player\'s position in any way in the move hook. This is because due to prediction errors, the netcode might run the move hook multiple times as packets arrive late. Therefore you should only adjust the movedata construct in this hook.\r\n\r\nGenerally you shouldn\'t have to use this hook - if you want to make a custom move type you should look at the drive system.\r\n\r\nThis hook is called after <page>GM:PlayerTick</page>.\r\n\r\nSee <page>Game Movement</page> for an explanation on the move system.\r\n```lua\rply: Player\r\n--Player\r\nmv: CMoveData\r\n--Movement information\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param mv CMoveData'
customsnip = 'Add("Move", "${1:name}", function(ply, mv)\n\t$0\nend)'

[NeedsDepthPass]
type = 'interface'
description = 'Returning true in this hook will cause it to render depth buffers defined with <page>render.GetResolvedFullFrameDepth</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("NeedsDepthPass", "${1:name}", function()\n\t$0\nend)'

[NetworkEntityCreated]
type = 'interface'
description = 'Called when an entity has been created over the network.\r\n```lua\rent: Entity\r\n--Created entity\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ent Entity'
customsnip = 'Add("NetworkEntityCreated", "${1:name}", function(ent)\n\t$0\nend)'

[NetworkIDValidated]
type = 'interface'
description = 'Called when a player has been validated by Steam.\r\n```lua\rname: string\r\n--Player name\r\nsteamID: string\r\n--Player SteamID\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param name string\n---@param steamID string'
customsnip = 'Add("NetworkIDValidated", "${1:name}", function(name, steamID)\n\t$0\nend)'

[NotifyShouldTransmit]
type = 'interface'
description = 'Called whenever this entity changes its transmission state for this <page>Global.LocalPlayer</page>, such as exiting or re entering the PVS.\r\n\r\n<note>This is the best place to handle the reset of <page>Entity:SetPredictable</page>, as this would be usually called when the player lags and requests a full packet update</note>\r\n\r\n<note>When the entity stops transmitting, <page>Entity:IsDormant</page> will only return true **after** this hook</note>\r\n```lua\rent: Entity\r\n--The entity that changed its transmission state.\r\nshouldtransmit: boolean\r\n--True if we started transmitting to this client and false if we stopped.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ent Entity\n---@param shouldtransmit boolean'
customsnip = 'Add("NotifyShouldTransmit", "${1:name}", function(ent, shouldtransmit)\n\t$0\nend)'

[OnAchievementAchieved]
type = 'interface'
description = 'Called when a player has achieved an achievement. You can get the name and other information from an achievement ID with the <page>achievements</page> library.\r\n```lua\rply: Player\r\n--The player that earned the achievement\r\nachievement: number\r\n--The index of the achievement\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param achievement number'
customsnip = 'Add("OnAchievementAchieved", "${1:name}", function(ply, achievement)\n\t$0\nend)'

[OnChatTab]
type = 'interface'
description = 'Called when the local player presses TAB while having their chatbox opened.\r\n```lua\rtext: string\r\n--The currently typed into chatbox text\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param text string'
customsnip = 'Add("OnChatTab", "${1:name}", function(text)\n\t$0\nend)'

[OnCleanup]
type = 'interface'
description = 'Called when the player cleans up something.\r\n```lua\rname: string\r\n--The name of the cleanup type\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param name string'
customsnip = 'Add("OnCleanup", "${1:name}", function(name)\n\t$0\nend)'

[OnContextMenuClose]
type = 'interface'
description = 'Called when the context menu keybind (+menu_context) is released, which by default is C.\r\n\r\nThis hook will not run if <page>input.IsKeyTrapping</page> returns true.\r\n\r\nSee also <page>GM:OnContextMenuOpen</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnContextMenuClose", "${1:name}", function()\n\t$0\nend)'

[OnContextMenuOpen]
type = 'interface'
description = 'Called when the context menu keybind (+menu_context) is pressed, which by default is C.\r\n\r\nSee also <page>GM:OnContextMenuClose</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnContextMenuOpen", "${1:name}", function()\n\t$0\nend)'

[OnCrazyPhysics]
type = 'interface'
description = 'Called when the crazy physics detection detects an entity with Crazy Physics.\r\n```lua\rent: Entity\r\n--The entity that was detected as crazy\r\nphysobj: PhysObj\r\n--The physics object that is going crazy\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity\n---@param physobj PhysObj'
customsnip = 'Add("OnCrazyPhysics", "${1:name}", function(ent, physobj)\n\t$0\nend)'

[OnDamagedByExplosion]
type = 'interface'
description = 'Called when a player has been hurt by an explosion. Override to disable default sound effect.\r\n```lua\rply: Player\r\n--Player who has been hurt\r\ndmginfo: CTakeDamageInfo\r\n--Damage info from explsion\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param dmginfo CTakeDamageInfo'
customsnip = 'Add("OnDamagedByExplosion", "${1:name}", function(ply, dmginfo)\n\t$0\nend)'

[OnEntityCreated]
type = 'interface'
description = 'Called when the entity is created.\r\n\r\n<note>Some entities on initial map spawn are passed through this hook, and then removed in the same frame. This is used by the engine to precache things like models and sounds, so always check their validity with <page>Global.IsValid</page>.</note>\r\n\r\n<warning>Removing the created entity during this event can lead to unexpected problems. Use <page>timer.Simple</page>( 0, .... ) to safely remove the entity.</warning>\r\n```lua\rentity: Entity\r\n--The entity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param entity Entity'
customsnip = 'Add("OnEntityCreated", "${1:name}", function(entity)\n\t$0\nend)'

[OnEntityWaterLevelChanged]
type = 'interface'
description = 'Called when the <page>Entity:WaterLevel</page> of an entity is changed.\r\n<warning>This hook can be considered a physics callback, so changing collision rules (<page>Entity:SetSolidFlags</page>) in it may lead to a crash!</warning>\r\n```lua\rentity: Entity\r\n--The entity.\r\nold: number\r\n--Previous water level.\r\nnew: number\r\n--The new water level.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param entity Entity\n---@param old number\n---@param new number'
customsnip = 'Add("OnEntityWaterLevelChanged", "${1:name}", function(entity, old, new)\n\t$0\nend)'

[OnGamemodeLoaded]
type = 'interface'
description = 'Called when the gamemode is loaded.\r\n\r\n<page>Global.LocalPlayer</page>() returns NULL at the time this is run.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnGamemodeLoaded", "${1:name}", function()\n\t$0\nend)'

[OnLuaError]
type = 'interface'
description = 'Called when a Lua error occurs, only works in the Menu realm.\r\n\r\n<warning>Modify menu state Lua code at your own risk!</warning>\r\n```lua\rerror: string\r\n--The error that occurred.\r\nrealm: number\r\n--Where the Lua error took place\r\nstack: table\r\n--The Lua error stack trace\r\nname: string\r\n--Title of the addon that is creating the Lua errors.\r\nid: number\r\n--Steam Workshop ID of the addon creating Lua errors, if it is an addon.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param error string\n---@param realm number\n---@param stack table\n---@param name string\n---@param id number'
customsnip = 'Add("OnLuaError", "${1:name}", function(error, realm, stack, name, id)\n\t$0\nend)'

[OnNPCKilled]
type = 'interface'
description = 'Called whenever an NPC is killed.\r\n```lua\rnpc: NPC\r\n--The killed NPC\r\nattacker: Entity\r\n--The NPCs attacker, the entity that gets the kill credit, for example a player or an NPC.\r\ninflictor: Entity\r\n--Death inflictor. The entity that did the killing. Not necessarily a weapon.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param npc NPC\n---@param attacker Entity\n---@param inflictor Entity'
customsnip = 'Add("OnNPCKilled", "${1:name}", function(npc, attacker, inflictor)\n\t$0\nend)'

[OnPhysgunFreeze]
type = 'interface'
description = 'Called when a player freezes an entity with the physgun.\r\n\r\n<bug issue="723">This is not called for players or NPCs being held with the physgun.</bug>\r\n```lua\rweapon: Entity\r\n--The weapon that was used to freeze the entity.\r\nphysobj: PhysObj\r\n--Physics object of the entity.\r\nent: Entity\r\n--The target entity.\r\nply: Player\r\n--The player who tried to freeze the entity.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param weapon Entity\n---@param physobj PhysObj\n---@param ent Entity\n---@param ply Player'
customsnip = 'Add("OnPhysgunFreeze", "${1:name}", function(weapon, physobj, ent, ply)\n\t$0\nend)'

[OnPhysgunPickup]
type = 'interface'
description = 'Called to when a player has successfully picked up an entity with their Physics Gun.\r\n\r\nNot to be confused with <page>GM:PhysgunPickup</page> which is called multiple times to ask if the player should be able to pick up an entity.\r\n```lua\rply: Player\r\n--The player that has picked up something using the physics gun.\r\nent: Entity\r\n--The entity that was picked up.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("OnPhysgunPickup", "${1:name}", function(ply, ent)\n\t$0\nend)'

[OnPhysgunReload]
type = 'interface'
description = 'Called when a player reloads with the physgun. Override this to disable default unfreezing behavior.\r\n```lua\rphysgun: Weapon\r\n--The physgun in question\r\nply: Player\r\n--The player wielding the physgun\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param physgun Weapon\n---@param ply Player'
customsnip = 'Add("OnPhysgunReload", "${1:name}", function(physgun, ply)\n\t$0\nend)'

[OnPlayerChangedTeam]
type = 'interface'
description = '<deprecated>Use <page>GM:PlayerChangedTeam</page> instead, which works for every <page>Player:SetTeam</page> call.</deprecated>\r\nCalled when a player has changed team using <page>GM:PlayerJoinTeam</page>.\r\n\r\n<warning>This hook will not work with <page>hook.Add</page> and it is only called manually from <page>GM:PlayerJoinTeam</page> by the base gamemode</warning>\r\n```lua\rply: Player\r\n--Player who has changed team\r\noldTeam: number\r\n--Index of the team the player was originally in\r\nnewTeam: number\r\n--Index of the team the player has changed to\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param oldTeam number\n---@param newTeam number'
customsnip = 'Add("OnPlayerChangedTeam", "${1:name}", function(ply, oldTeam, newTeam)\n\t$0\nend)'

[OnPlayerChat]
type = 'interface'
description = 'Called whenever a player sends a chat message. For the serverside equivalent, see <page>GM:PlayerSay</page>.\r\n<note>The text input of this hook depends on <page>GM:PlayerSay</page>. If it is suppressed on the server, it will be suppressed on the client. This also means, that a message surpressed with this hook will be still visible to other clients.</note>\r\n```lua\rply: Player\r\n--The player\r\ntext: string\r\n--The message\'s text\r\nteamChat: boolean\r\n--Is the player typing in team chat?\r\nisDead: boolean\r\n--Is the player dead?\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param text string\n---@param teamChat boolean\n---@param isDead boolean'
customsnip = 'Add("OnPlayerChat", "${1:name}", function(ply, text, teamChat, isDead)\n\t$0\nend)'

[OnPlayerHitGround]
type = 'interface'
description = 'Called when a player makes contact with the ground after a jump or a fall.\r\n```lua\rplayer: Entity\r\n--Player\r\ninWater: boolean\r\n--Did the player land in water?\r\nonFloater: boolean\r\n--Did the player land on an object floating in the water?\r\nspeed: number\r\n--The speed at which the player hit the ground\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param player Entity\n---@param inWater boolean\n---@param onFloater boolean\n---@param speed number'
customsnip = 'Add("OnPlayerHitGround", "${1:name}", function(player, inWater, onFloater, speed)\n\t$0\nend)'

[OnReloaded]
type = 'interface'
description = 'Called when gamemode has been reloaded by auto refresh.\r\n\r\n<note>It seems that this event can be triggered more than once for a single refresh event.</note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnReloaded", "${1:name}", function()\n\t$0\nend)'

[OnScreenSizeChanged]
type = 'interface'
description = 'Called when the player\'s screen resolution of the game changes.\r\n<page>Global.ScrW</page> and <page>Global.ScrH</page> will return the new values when this hook is called.\r\n```lua\roldWidth: number\r\n--The previous width of the game\'s window.\r\noldHeight: number\r\n--The previous height of the game\'s window.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param oldWidth number\n---@param oldHeight number'
customsnip = 'Add("OnScreenSizeChanged", "${1:name}", function(oldWidth, oldHeight)\n\t$0\nend)'

[OnSpawnMenuClose]
type = 'interface'
description = 'Called when a player releases the `+menu` bind on their keyboard, which is bound to Q by default.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnSpawnMenuClose", "${1:name}", function()\n\t$0\nend)'

[OnSpawnMenuOpen]
type = 'interface'
description = 'Called when a player presses the `+menu` bind on their keyboard, which is bound to Q by default.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnSpawnMenuOpen", "${1:name}", function()\n\t$0\nend)'

[OnTextEntryGetFocus]
type = 'interface'
description = 'Called when a <page>DTextEntry</page> gets focus.\r\n\r\nThis hook is run from <page>DTextEntry:OnGetFocus</page> and <page>PANEL:OnMousePressed</page> of <page>DTextEntry</page>.\r\n```lua\rpanel: Panel\r\n--The panel that got focus\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param panel Panel'
customsnip = 'Add("OnTextEntryGetFocus", "${1:name}", function(panel)\n\t$0\nend)'

[OnTextEntryLoseFocus]
type = 'interface'
description = 'Called when DTextEntry loses focus.\r\n```lua\rpanel: Panel\r\n--The panel that lost focus\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param panel Panel'
customsnip = 'Add("OnTextEntryLoseFocus", "${1:name}", function(panel)\n\t$0\nend)'

[OnUndo]
type = 'interface'
description = 'Called when the player undoes something.\r\n```lua\rname: string\r\n--The name of the undo action\r\ncustomText: string\r\n--The custom text for the undo, set by <page>undo.SetCustomUndoText</page>\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param name string\n---@param customText string'
customsnip = 'Add("OnUndo", "${1:name}", function(name, customText)\n\t$0\nend)'

[OnViewModelChanged]
type = 'interface'
description = 'Called when the player changes their weapon to another one - and their viewmodel model changes.\r\n\r\n<bug issue="2473">This is not always called clientside.</bug>\r\n```lua\rviewmodel: Entity\r\n--The viewmodel that is changing\r\noldModel: string\r\n--The old model\r\nnewModel: string\r\n--The new model\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param viewmodel Entity\n---@param oldModel string\n---@param newModel string'
customsnip = 'Add("OnViewModelChanged", "${1:name}", function(viewmodel, oldModel, newModel)\n\t$0\nend)'

[PhysgunDrop]
type = 'interface'
description = 'Called when a player drops an entity with the Physgun.\r\n```lua\rply: Player\r\n--The player who dropped an entitiy\r\nent: Entity\r\n--The dropped entity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PhysgunDrop", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PhysgunPickup]
type = 'interface'
description = 'Called to determine if a player should be able to pick up an entity with the Physics Gun.\r\n\r\nSee <page>GM:OnPhysgunPickup</page> for a hook which is called when a player has successfully picked up an entity.\r\n```lua\rplayer: Player\r\n--The player that is picking up using the Physics Gun.\r\nentity: Entity\r\n--The entity that is being picked up.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param player Player\n---@param entity Entity'
customsnip = 'Add("PhysgunPickup", "${1:name}", function(player, entity)\n\t$0\nend)'

[PlayerAmmoChanged]
type = 'interface'
description = 'Called when player\'s reserve ammo count changes.\r\n```lua\rply: Player\r\n--The player whose ammo is being affected.\r\nammoID: number\r\n--The ammo type ID.\r\noldCount: number\r\n--The old ammo count.\r\nnewCount: number\r\n--The new ammo count.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param ammoID number\n---@param oldCount number\n---@param newCount number'
customsnip = 'Add("PlayerAmmoChanged", "${1:name}", function(ply, ammoID, oldCount, newCount)\n\t$0\nend)'

[PlayerAuthed]
type = 'interface'
description = 'Called once when the player is authenticated.\r\n\r\n<bug issue="3026"><page>Global.CurTime</page> returns 0 in this hook.</bug>\r\n```lua\rply: Player\r\n--The player\r\nsteamid: string\r\n--The player\'s SteamID\r\nuniqueid: string\r\n--The player\'s UniqueID\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param steamid string\n---@param uniqueid string'
customsnip = 'Add("PlayerAuthed", "${1:name}", function(ply, steamid, uniqueid)\n\t$0\nend)'

[PlayerBindPress]
type = 'interface'
description = 'Runs when a bind has been pressed. Allows to block commands.\r\n\r\n<note>By using the "alias" console command, this hook can be effectively circumvented. To prevent this use <page>input.TranslateAlias</page>.</note>\r\n\r\n<note>To stop the user from using +attack, +left and any other movement commands of the sort, please look into using <page>GM:StartCommand</page> instead</note>\r\n\r\n<bug issue="1176">The third argument will always be true.</bug>\r\n\r\n<bug issue="2888">This does not run for function keys binds (F1-F12).</bug>\r\n```lua\rply: Player\r\n--The player who used the command; this will always be equal to <page>Global.LocalPlayer</page>\r\nbind: string\r\n--The bind command\r\npressed: boolean\r\n--If the bind was activated or deactivated\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param bind string\n---@param pressed boolean'
customsnip = 'Add("PlayerBindPress", "${1:name}", function(ply, bind, pressed)\n\t$0\nend)'

[PlayerButtonDown]
type = 'interface'
description = 'Called when a player presses a button.\r\n\r\nThis will not be called if player has a panel opened with keyboard input enabled, use <page>PANEL:OnKeyCodePressed</page> instead.\r\n```lua\rply: Player\r\n--Player who pressed the button\r\nbutton: number\r\n--The button, see <page>Enums/BUTTON_CODE</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param button number'
customsnip = 'Add("PlayerButtonDown", "${1:name}", function(ply, button)\n\t$0\nend)'

[PlayerButtonUp]
type = 'interface'
description = 'Called when a player releases a button.\r\n\r\nThis will not be called if player has a panel opened with keyboard input enabled, use <page>PANEL:OnKeyCodeReleased</page> instead.\r\n```lua\rply: Player\r\n--Player who released the button\r\nbutton: number\r\n--The button, see <page>Enums/BUTTON_CODE</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param button number'
customsnip = 'Add("PlayerButtonUp", "${1:name}", function(ply, button)\n\t$0\nend)'

[PlayerCanHearPlayersVoice]
type = 'interface'
description = 'Decides whether a player can hear another player using voice chat.\r\n\r\n<note>This hook is called several times a tick, so ensure your code is efficient.</note>\r\n```lua\rlistener: Player\r\n--The listening player.\r\ntalker: Player\r\n--The talking player.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param listener Player\n---@param talker Player'
customsnip = 'Add("PlayerCanHearPlayersVoice", "${1:name}", function(listener, talker)\n\t$0\nend)'

[PlayerCanJoinTeam]
type = 'interface'
description = 'Returns whether or not a player is allowed to join a team\r\n```lua\rply: Player\r\n--Player attempting to switch teams\r\nteam: number\r\n--Index of the team\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param team number'
customsnip = 'Add("PlayerCanJoinTeam", "${1:name}", function(ply, team)\n\t$0\nend)'

[PlayerCanPickupItem]
type = 'interface'
description = 'Returns whether or not a player is allowed to pick an item up.\r\n```lua\rply: Player\r\n--Player attempting to pick up\r\nitem: Entity\r\n--The item the player is attempting to pick up\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param item Entity'
customsnip = 'Add("PlayerCanPickupItem", "${1:name}", function(ply, item)\n\t$0\nend)'

[PlayerCanPickupWeapon]
type = 'interface'
description = 'Returns whether or not a player is allowed to pick up a weapon.\r\n```lua\rply: Player\r\n--The player attempting to pick up the weapon\r\nwep: Weapon\r\n--The weapon entity in question\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param wep Weapon'
customsnip = 'Add("PlayerCanPickupWeapon", "${1:name}", function(ply, wep)\n\t$0\nend)'

[PlayerCanSeePlayersChat]
type = 'interface'
description = 'Returns whether or not the player can see the other player\'s chat.\r\n<note>The **speaker** parameter does not have to be a valid <page>Player</page> object which happens when console messages are displayed for example.</note>\r\n```lua\rtext: string\r\n--The chat text\r\nteamOnly: boolean\r\n--If the message is team-only\r\nlistener: Player\r\n--The player receiving the message\r\nspeaker: Player\r\n--The player sending the message.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param text string\n---@param teamOnly boolean\n---@param listener Player\n---@param speaker Player'
customsnip = 'Add("PlayerCanSeePlayersChat", "${1:name}", function(text, teamOnly, listener, speaker)\n\t$0\nend)'

[PlayerChangedTeam]
type = 'interface'
description = 'Called when a player has changed team using <page>Player:SetTeam</page>.\r\n<warning>Avoid calling <page>Player:SetTeam</page> in this hook as it may cause an infinite loop!</warning>\r\n```lua\rply: Player\r\n--Player whose team has changed.\r\noldTeam: number\r\n--Index of the team the player was originally in. See <page>team.GetName</page> and the <page>team</page> library.\r\nnewTeam: number\r\n--Index of the team the player has changed to.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param oldTeam number\n---@param newTeam number'
customsnip = 'Add("PlayerChangedTeam", "${1:name}", function(ply, oldTeam, newTeam)\n\t$0\nend)'

[PlayerCheckLimit]
type = 'interface'
description = 'Called whenever a player is about to spawn something to see if they hit a limit for whatever they are spawning.\r\n<note>This hook will not be called in singleplayer, as singleplayer does not have limits.</note>\r\n```lua\rply: Player\r\n--The player who is trying to spawn something.\r\nlimitName: string\r\n--The limit\'s name.\r\ncurrent: number\r\n--The amount of whatever player is trying to spawn that the player already has spawned.\r\ndefaultMax: number\r\n--The default maximum count, as dictated by the `sbox_max<limitname>` convar on the server. This is the amount that will be used if nothing is returned from this hook.</limitname>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param limitName string\n---@param current number\n---@param defaultMax number'
customsnip = 'Add("PlayerCheckLimit", "${1:name}", function(ply, limitName, current, defaultMax)\n\t$0\nend)'

[PlayerClassChanged]
type = 'interface'
description = '<internal></internal>\r\n\r\nCalled whenever a player\'s class is changed on the server-side with <page>player_manager.SetPlayerClass</page>.\r\n```lua\rply: Player\r\n--The player whose class has been changed.\r\nnewID: number\r\n--The network ID of the player class\'s name string, or 0 if we are clearing a player class from the player.\r\n\r\nPass this into <page>util.NetworkIDToString</page> to retrieve the proper name of the player class.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param newID number'
customsnip = 'Add("PlayerClassChanged", "${1:name}", function(ply, newID)\n\t$0\nend)'

[PlayerConnect]
type = 'interface'
description = 'Executes when a player connects to the server. Called before the player has been assigned a <page text="UserID">Player:UserID</page> and entity. See the <page text="player_connect gameevent">Game_Events</page> for a version of this hook called after the player entity has been created.\r\n\r\n<note>This is only called clientside for listen server hosts.</note>\r\n<note>This is not called clientside for the local player.</note>\r\n```lua\rname: string\r\n--The player\'s name.\r\nip: string\r\n--The player\'s IP address. Will be "none" for bots.\r\n\r\n<note>This argument will only be passed serverside.</note>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param name string\n---@param ip string'
customsnip = 'Add("PlayerConnect", "${1:name}", function(name, ip)\n\t$0\nend)'

[PlayerDeath]
type = 'interface'
description = 'Called when a player is killed by <page>Player:Kill</page> or any other normal means.\r\n\r\nThis hook is **not** called if the player is killed by <page>Player:KillSilent</page>. See <page>GM:PlayerSilentDeath</page> for that.\r\n\r\n* <page>GM:DoPlayerDeath</page> is called **before** this hook.\r\n* <page>GM:PostPlayerDeath</page> is called **after** this hook.\r\n\r\nSee <page>Player:LastHitGroup</page> if you need to get the last hit hitgroup of the player.\r\n\r\n<note><page>Player:Alive</page> will return true in this hook.</note>\r\n```lua\rvictim: Player\r\n--The player who died\r\ninflictor: Entity\r\n--Item used to kill the victim\r\nattacker: Entity\r\n--Player or entity that killed the victim\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param victim Player\n---@param inflictor Entity\n---@param attacker Entity'
customsnip = 'Add("PlayerDeath", "${1:name}", function(victim, inflictor, attacker)\n\t$0\nend)'

[PlayerDeathSound]
type = 'interface'
description = 'Returns whether or not the default death sound should be muted.\r\n\r\n**Scope:** Server'
customsnip = 'Add("PlayerDeathSound", "${1:name}", function()\n\t$0\nend)'

[PlayerDeathThink]
type = 'interface'
description = 'Called every think while the player is dead. The return value will determine if the player respawns.\r\n\r\nOverwriting this function will prevent players from respawning by pressing space or clicking.\r\n\r\n<bug issue="1577">This hook is not called for players with the <page text="FL_FROZEN">Enums/FL</page> flag applied.</bug>\r\n```lua\rply: Player\r\n--The player affected in the hook.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PlayerDeathThink", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerDisconnected]
type = 'interface'
description = 'Called when a player leaves the server. See the <page text="player_disconnect gameevent">Game_Events</page> for a shared version of this hook.\r\n<validate><page>Player:SteamID</page>, <page>Player:SteamID64</page>, and the like can return nil here.</validate>\r\n\r\n<bug issue="3523">This is not called in single-player or listen servers for the host.</bug>\r\n```lua\rply: Player\r\n--the player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PlayerDisconnected", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerDriveAnimate]
type = 'interface'
description = 'Called to update the player\'s animation during a drive.\r\n```lua\rply: Player\r\n--The driving player\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("PlayerDriveAnimate", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerDroppedWeapon]
type = 'interface'
description = 'Called when a weapon is dropped by a player via <page>Player:DropWeapon</page>.\r\n\r\nAlso called when a weapon is removed from a player via <page>Player:StripWeapon</page>.\r\n\r\nSee also <page>GM:WeaponEquip</page> for a hook when a player picks up a weapon.\r\n\r\nThe weapon\'s <page>Entity:GetOwner</page> will be NULL at the time this hook is called.\r\n\r\n\r\n<page>WEAPON:OnDrop</page> will be called before this hook is.\r\n```lua\rowner: Player\r\n--The player who owned this weapon before it was dropped\r\nwep: Weapon\r\n--The weapon that was dropped\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param owner Player\n---@param wep Weapon'
customsnip = 'Add("PlayerDroppedWeapon", "${1:name}", function(owner, wep)\n\t$0\nend)'

[PlayerEndVoice]
type = 'interface'
description = 'Called when player stops using voice chat.\r\n```lua\rply: Player\r\n--Player who stopped talking\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player'
customsnip = 'Add("PlayerEndVoice", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerEnteredVehicle]
type = 'interface'
description = 'Called when a player enters a vehicle.\r\n\r\nCalled just after <page>GM:CanPlayerEnterVehicle</page>.\r\n\r\nSee also <page>GM:PlayerLeaveVehicle</page>.\r\n```lua\rply: Player\r\n--Player who entered vehicle\r\nveh: Vehicle\r\n--Vehicle the player entered\r\nrole: number\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param veh Vehicle\n---@param role number'
customsnip = 'Add("PlayerEnteredVehicle", "${1:name}", function(ply, veh, role)\n\t$0\nend)'

[PlayerFootstep]
type = 'interface'
description = 'Called whenever a player steps. Return true to mute the normal sound.\r\n```lua\rply: Player\r\n--The stepping player\r\npos: Vector\r\n--The position of the step\r\nfoot: number\r\n--Foot that is stepped. 0 for left, 1 for right\r\nsound: string\r\n--Sound that is going to play\r\nvolume: number\r\n--Volume of the footstep\r\nfilter: CRecipientFilter\r\n--The Recipient filter of players who can hear the footstep\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param pos Vector\n---@param foot number\n---@param sound string\n---@param volume number\n---@param filter CRecipientFilter'
customsnip = 'Add("PlayerFootstep", "${1:name}", function(ply, pos, foot, sound, volume, filter)\n\t$0\nend)'

[PlayerFrozeObject]
type = 'interface'
description = 'Called when a player freezes an object.\r\n```lua\rply: Player\r\n--Player who has frozen an object\r\nent: Entity\r\n--The frozen object\r\nphysobj: PhysObj\r\n--The frozen physics object of the frozen entity ( For ragdolls )\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity\n---@param physobj PhysObj'
customsnip = 'Add("PlayerFrozeObject", "${1:name}", function(ply, ent, physobj)\n\t$0\nend)'

[PlayerHurt]
type = 'interface'
description = 'Called when a player gets hurt.\r\n```lua\rvictim: Player\r\n--Victim\r\nattacker: Entity\r\n--Attacker Entity\r\nhealthRemaining: number\r\n--Remaining Health\r\ndamageTaken: number\r\n--Damage Taken\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param victim Player\n---@param attacker Entity\n---@param healthRemaining number\n---@param damageTaken number'
customsnip = 'Add("PlayerHurt", "${1:name}", function(victim, attacker, healthRemaining, damageTaken)\n\t$0\nend)'

[PlayerInitialSpawn]
type = 'interface'
description = 'Called when the player spawns for the first time.\r\n\r\nSee <page>GM:PlayerSpawn</page> for a hook called every player spawn.\r\n\r\n<note>This hook is called before the player has fully loaded, when the player is still in seeing the "Starting Lua" screen. For example, trying to use the <page>Entity:GetModel</page> function will return the default model ("models/player.mdl")</note>\r\n<warning>Due to the above note, sending <page>net</page> messages to the spawned player in this hook are highly unreliable, and they most likely won\'t be received. See https://github.com/Facepunch/garrysmod-requests/issues/718.\r\n\r\nCurrent dirty hack without networking:\r\n```\r\nhook.Add( "PlayerInitialSpawn", "FullLoadSetup", function( ply )\r\nhook.Add( "SetupMove", ply, function(self, ply, _, cmd )\r\nif self == ply and not cmd:IsForced() then hook.Run( "PlayerFullLoad", self ) hook.Remove( "SetupMove", self ) end\r\nend )\r\nend )\r\n```\r\n\r\nWith networking:\r\n```\r\n-- CLIENT\r\nhook.Add( "InitPostEntity", "Ready", function()\r\nnet.Start( "cool_addon_client_ready" )\r\nnet.SendToServer()\r\nend )\r\n```\r\n```\r\n-- SERVER\r\nutil.AddNetworkString( "cool_addon_client_ready" )\r\n\r\nnet.Receive( "cool_addon_client_ready", function( len, ply )\r\n--send what you need here!\r\nend )\r\n```\r\n</warning>\r\n```lua\rplayer: Player\r\n--The player who spawned.\r\ntransition: boolean\r\n--If true, the player just spawned from a map transition.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param player Player\n---@param transition boolean'
customsnip = 'Add("PlayerInitialSpawn", "${1:name}", function(player, transition)\n\t$0\nend)'

[PlayerJoinTeam]
type = 'interface'
description = 'Makes the player join a specified team. This is a convenience function that calls <page>Player:SetTeam</page> and runs the <page>GM:OnPlayerChangedTeam</page> hook.\r\n```lua\rply: Player\r\n--Player to force\r\nteam: number\r\n--The team to put player into\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param team number'
customsnip = 'Add("PlayerJoinTeam", "${1:name}", function(ply, team)\n\t$0\nend)'

[PlayerLeaveVehicle]
type = 'interface'
description = 'Called when a player leaves a vehicle.\r\n\r\n<note>For vehicles with exit animations, this will be called **at the end** of the animation, **not at the start**!</note>\r\n\r\n<bug issue="2619">This is not called when a different vehicle is immediately entered with <page>Player:EnterVehicle</page>.</bug>\r\n```lua\rply: Player\r\n--Player who left a vehicle.\r\nveh: Vehicle\r\n--Vehicle the player left.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param veh Vehicle'
customsnip = 'Add("PlayerLeaveVehicle", "${1:name}", function(ply, veh)\n\t$0\nend)'

[PlayerLoadout]
type = 'interface'
description = 'Called to give players the default set of weapons.\r\n\r\n\r\n<note>This function may not work in your custom gamemode if you have overridden your <page>GM:PlayerSpawn</page> and you do not use self.BaseClass.PlayerSpawn or <page>hook.Call</page>.</note>\r\n```lua\rply: Player\r\n--Player to give weapons to.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PlayerLoadout", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerNoClip]
type = 'interface'
description = 'Called when a player tries to switch noclip mode.\r\n```lua\rply: Player\r\n--The person who entered/exited noclip\r\ndesiredState: boolean\r\n--Represents the noclip state (on/off) the user will enter if this hook allows them to.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param desiredState boolean'
customsnip = 'Add("PlayerNoClip", "${1:name}", function(ply, desiredState)\n\t$0\nend)'

[PlayerPostThink]
type = 'interface'
description = 'Called after the player\'s think.\r\n```lua\rply: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("PlayerPostThink", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerRequestTeam]
type = 'interface'
description = 'Request a player to join the team. This function will check if the team is available to join or not.\r\n\r\nThis hook is called when the player runs "changeteam" in the console.\r\n\r\nTo prevent the player from changing teams, see <page>GM:PlayerCanJoinTeam</page>\r\n```lua\rply: Player\r\n--The player to try to put into a team\r\nteam: number\r\n--Team to put the player into if the checks succeeded\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param team number'
customsnip = 'Add("PlayerRequestTeam", "${1:name}", function(ply, team)\n\t$0\nend)'

[PlayerSay]
type = 'interface'
description = 'Called when a player dispatched a chat message. For the clientside equivalent, see <page>GM:OnPlayerChat</page>.\r\n```lua\rsender: Player\r\n--The player which sent the message.\r\ntext: string\r\n--The message\'s content\r\nteamChat: boolean\r\n--Is team chat?\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param sender Player\n---@param text string\n---@param teamChat boolean'
customsnip = 'Add("PlayerSay", "${1:name}", function(sender, text, teamChat)\n\t$0\nend)'

[PlayerSelectSpawn]
type = 'interface'
description = 'Called to determine a spawn point for a player to spawn at.\r\n```lua\rply: Player\r\n--The player who needs a spawn point\r\ntransition: boolean\r\n--If true, the player just spawned from a map transition. You probably want to not return an entity for that case to not override player\'s position.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param transition boolean'
customsnip = 'Add("PlayerSelectSpawn", "${1:name}", function(ply, transition)\n\t$0\nend)'

[PlayerSelectTeamSpawn]
type = 'interface'
description = 'Find a team spawn point entity for this player.\r\n```lua\rteam: number\r\n--Players team\r\nply: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param team number\n---@param ply Player'
customsnip = 'Add("PlayerSelectTeamSpawn", "${1:name}", function(team, ply)\n\t$0\nend)'

[PlayerSetHandsModel]
type = 'interface'
description = 'Called whenever view model hands needs setting a model. By default this calls <page>PLAYER:GetHandsModel</page> and if that fails, sets the hands model according to his player model.\r\n```lua\rply: Player\r\n--The player whose hands needs a model set\r\nent: Entity\r\n--The hands to set model of\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PlayerSetHandsModel", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PlayerSetModel]
type = 'interface'
description = 'Called whenever a player spawns and must choose a model. A good place to assign a model to a player.\r\n<note>This function may not work in your custom gamemode if you have overridden your <page>GM:PlayerSpawn</page> and you do not use self.BaseClass.PlayerSpawn or <page>hook.Call</page>.</note>\r\n```lua\rply: Player\r\n--The player being chosen\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PlayerSetModel", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerShouldTakeDamage]
type = 'interface'
description = 'Returns true if the player should take damage from the given attacker.\r\n```lua\rply: Player\r\n--The player\r\nattacker: Entity\r\n--The attacker\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param attacker Entity'
customsnip = 'Add("PlayerShouldTakeDamage", "${1:name}", function(ply, attacker)\n\t$0\nend)'

[PlayerShouldTaunt]
type = 'interface'
description = 'Allows to suppress player taunts.\r\n```lua\rply: Player\r\n--Player who tried to taunt\r\nact: number\r\n--Act ID of the taunt player tries to do, see <page>Enums/ACT</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param act number'
customsnip = 'Add("PlayerShouldTaunt", "${1:name}", function(ply, act)\n\t$0\nend)'

[PlayerSilentDeath]
type = 'interface'
description = 'Called when the player is killed by <page>Player:KillSilent</page>.\r\n\r\nThe player is already considered dead when this hook is called.\r\n\r\n* See <page>GM:PlayerDeath</page> for a hook which handles all other death causes.\r\n* <page>GM:PostPlayerDeath</page> is called **after** this hook.\r\n\r\n<note><page>Player:Alive</page> will return true in this hook.</note>\r\n```lua\rply: Player\r\n--The player who was killed\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PlayerSilentDeath", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerSpawn]
type = 'interface'
description = 'Called whenever a player spawns, including respawns.\r\n\r\nSee <page>GM:PlayerInitialSpawn</page> for a hook called only the first time a player spawns.\r\n\r\nSee the <page text="player_spawn gameevent">Game_Events</page> for a shared version of this hook.\r\n\r\n<warning>By default, in "base" derived gamemodes, this hook will also call <page>GM:PlayerLoadout</page> and <page>GM:PlayerSetModel</page>, which may override your <page>Entity:SetModel</page> and <page>Player:Give</page> calls. Consider using the other hooks or a 0-second timer.</warning>\r\n```lua\rplayer: Player\r\n--The player who spawned.\r\ntransition: boolean\r\n--If true, the player just spawned from a map transition. You probably want to not touch player\'s weapons if this is set to true from this hook.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param player Player\n---@param transition boolean'
customsnip = 'Add("PlayerSpawn", "${1:name}", function(player, transition)\n\t$0\nend)'

[PlayerSpawnAsSpectator]
type = 'interface'
description = 'Called to spawn the player as a spectator.\r\n```lua\rply: Player\r\n--The player to spawn as a spectator\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PlayerSpawnAsSpectator", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerSpray]
type = 'interface'
description = 'Determines if the player can spray using the "impulse 201" console command.\r\n```lua\rsprayer: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param sprayer Player'
customsnip = 'Add("PlayerSpray", "${1:name}", function(sprayer)\n\t$0\nend)'

[PlayerStartTaunt]
type = 'interface'
description = 'Called when player starts taunting.\r\n```lua\rply: Player\r\n--The player who is taunting\r\nact: number\r\n--The sequence ID of the taunt\r\nlength: number\r\n--Length of the taunt\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param act number\n---@param length number'
customsnip = 'Add("PlayerStartTaunt", "${1:name}", function(ply, act, length)\n\t$0\nend)'

[PlayerStartVoice]
type = 'interface'
description = 'Called when a player starts using voice chat.\r\n```lua\rply: Player\r\n--Player who started using voice chat\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player'
customsnip = 'Add("PlayerStartVoice", "${1:name}", function(ply)\n\t$0\nend)'

[PlayerStepSoundTime]
type = 'interface'
description = 'Allows you to override the time between footsteps.\r\n```lua\rply: Player\r\n--Player who is walking\r\ntype: number\r\n--The type of footsteps, see <page>Enums/STEPSOUNDTIME</page>\r\nwalking: boolean\r\n--Is the player walking or not ( +walk? )\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param type number\n---@param walking boolean'
customsnip = 'Add("PlayerStepSoundTime", "${1:name}", function(ply, type, walking)\n\t$0\nend)'

[PlayerSwitchFlashlight]
type = 'interface'
description = 'Called whenever a player attempts to either turn on or off their flashlight, returning false will deny the change.\r\n<note>Also gets called when using <page>Player:Flashlight</page>.</note>\r\n```lua\rply: Player\r\n--The player who attempts to change their flashlight state.\r\nenabled: boolean\r\n--The new state the player requested, true for on, false for off.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param enabled boolean'
customsnip = 'Add("PlayerSwitchFlashlight", "${1:name}", function(ply, enabled)\n\t$0\nend)'

[PlayerSwitchWeapon]
type = 'interface'
description = 'Called when a player switches their weapon.\r\n```lua\rplayer: Player\r\n--The player switching weapons.\r\noldWeapon: Weapon\r\n--The previous weapon. Will be NULL if the previous weapon was removed or the player is switching from nothing.\r\nnewWeapon: Weapon\r\n--The weapon the player switched to. Will be NULL if the player is switching to nothing.\r\n\r\n<bug issue="2922">This can be NULL on the client if the weapon hasn\'t been created over the network yet.</bug>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param player Player\n---@param oldWeapon Weapon\n---@param newWeapon Weapon'
customsnip = 'Add("PlayerSwitchWeapon", "${1:name}", function(player, oldWeapon, newWeapon)\n\t$0\nend)'

[PlayerTick]
type = 'interface'
description = 'The Move hook is called for you to manipulate the player\'s <page>CMoveData</page>. This hook is called moments before <page>GM:Move</page> and <page>GM:PlayerNoClip</page>.\r\n\r\n<warning>This hook will not run when inside a vehicle. <page>GM:VehicleMove</page> will be called instead.</warning>\r\n```lua\rplayer: Player\r\n--The player\r\nmv: CMoveData\r\n--The current movedata for the player.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param player Player\n---@param mv CMoveData'
customsnip = 'Add("PlayerTick", "${1:name}", function(player, mv)\n\t$0\nend)'

[PlayerTraceAttack]
type = 'interface'
description = 'Called when a player has been hit by a trace and damaged (such as from a bullet). Returning true overrides the damage handling and prevents <page>GM:ScalePlayerDamage</page> from being called.\r\n```lua\rply: Player\r\n--The player that has been hit\r\ndmginfo: CTakeDamageInfo\r\n--The damage info of the bullet\r\ndir: Vector\r\n--Normalized vector direction of the bullet\'s path\r\ntrace: table\r\n--The trace of the bullet\'s path, see <page>Structures/TraceResult</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param dmginfo CTakeDamageInfo\n---@param dir Vector\n---@param trace table'
customsnip = 'Add("PlayerTraceAttack", "${1:name}", function(ply, dmginfo, dir, trace)\n\t$0\nend)'

[PlayerUnfrozeObject]
type = 'interface'
description = 'Called when a player unfreezes an object.\r\n```lua\rply: Player\r\n--Player who has unfrozen an object\r\nent: Entity\r\n--The unfrozen object\r\nphysobj: PhysObj\r\n--The frozen physics object of the unfrozen entity ( For ragdolls )\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity\n---@param physobj PhysObj'
customsnip = 'Add("PlayerUnfrozeObject", "${1:name}", function(ply, ent, physobj)\n\t$0\nend)'

[PlayerUse]
type = 'interface'
description = 'Triggered when the player presses use on an object. Continuously runs until USE is released but will not activate other Entities until the USE key is released; dependent on activation type of the Entity.\r\n```lua\rply: Player\r\n--The player pressing the "use" key.\r\nent: Entity\r\n--The entity which the player is looking at / activating USE on.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PlayerUse", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PopulateMenuBar]
type = 'interface'
description = 'Called when it\'s time to populate the context menu menu bar at the top.\r\n```lua\rmenubar: Panel\r\n--The <page>DMenuBar</page> itself.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param menubar Panel'
customsnip = 'Add("PopulateMenuBar", "${1:name}", function(menubar)\n\t$0\nend)'

[PostCleanupMap]
type = 'interface'
description = 'Called right after the map has cleaned up (usually because <page>game.CleanUpMap</page> was called)\r\n\r\nSee also <page>GM:PreCleanupMap</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("PostCleanupMap", "${1:name}", function()\n\t$0\nend)'

[PostDraw2DSkyBox]
type = 'interface'
description = 'Called right after the 2D skybox has been drawn - allowing you to draw over it.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostDraw2DSkyBox", "${1:name}", function()\n\t$0\nend)'

[PostDrawEffects]
type = 'interface'
description = 'Called after rendering effects. This is where halos are drawn. Called just before <page>GM:PreDrawHUD</page>.\r\n\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostDrawEffects", "${1:name}", function()\n\t$0\nend)'

[PostDrawHUD]
type = 'interface'
description = 'Called after <page>GM:PreDrawHUD</page>,  <page>GM:HUDPaintBackground</page> and <page>GM:HUDPaint</page> but before  <page>GM:DrawOverlay</page>.\r\n\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostDrawHUD", "${1:name}", function()\n\t$0\nend)'

[PostDrawOpaqueRenderables]
type = 'interface'
description = 'Called after drawing opaque entities.\r\n\r\nSee also <page>GM:PostDrawTranslucentRenderables</page> and  <page>GM:PreDrawOpaqueRenderables</page>.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n```lua\rbDrawingDepth: boolean\r\n--Whether the current draw is writing depth.\r\nbDrawingSkybox: boolean\r\n--Whether the current draw is drawing the skybox.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param bDrawingDepth boolean\n---@param bDrawingSkybox boolean'
customsnip = 'Add("PostDrawOpaqueRenderables", "${1:name}", function(bDrawingDepth, bDrawingSkybox)\n\t$0\nend)'

[PostDrawPlayerHands]
type = 'interface'
description = 'Called after the player hands are drawn.\r\n```lua\rhands: Entity\r\n--This is the gmod_hands entity.\r\nvm: Entity\r\n--This is the view model entity.\r\nply: Player\r\n--The the owner of the view model.\r\nweapon: Weapon\r\n--This is the weapon that is from the view model.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param hands Entity\n---@param vm Entity\n---@param ply Player\n---@param weapon Weapon'
customsnip = 'Add("PostDrawPlayerHands", "${1:name}", function(hands, vm, ply, weapon)\n\t$0\nend)'

[PostDrawSkyBox]
type = 'interface'
description = 'Called after drawing the skybox.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostDrawSkyBox", "${1:name}", function()\n\t$0\nend)'

[PostDrawTranslucentRenderables]
type = 'interface'
description = 'Called after all translucent entities are drawn.\r\n\r\nSee also <page>GM:PostDrawOpaqueRenderables</page> and  <page>GM:PreDrawTranslucentRenderables</page>.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n<bug issue="3295">This is still called when r_drawentities or r_drawopaquerenderables is disabled.</bug>\r\n<bug issue="3296">This is not called when r_drawtranslucentworld is disabled.</bug>\r\n```lua\rbDrawingDepth: boolean\r\n--Whether the current call is writing depth.\r\nbDrawingSkybox: boolean\r\n--Whether the current call is drawing skybox.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param bDrawingDepth boolean\n---@param bDrawingSkybox boolean'
customsnip = 'Add("PostDrawTranslucentRenderables", "${1:name}", function(bDrawingDepth, bDrawingSkybox)\n\t$0\nend)'

[PostDrawViewModel]
type = 'interface'
description = 'Called after view model is drawn.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n<note>The 3D rendering context in this event is different from the main view. Every render operation will only be accurate with the view model entity.</note>\r\n```lua\rviewmodel: Entity\r\n--Players view model\r\nplayer: Player\r\n--The owner of the weapon/view model\r\nweapon: Weapon\r\n--The weapon the player is currently holding\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param viewmodel Entity\n---@param player Player\n---@param weapon Weapon'
customsnip = 'Add("PostDrawViewModel", "${1:name}", function(viewmodel, player, weapon)\n\t$0\nend)'

[PostEntityTakeDamage]
type = 'interface'
description = 'Called when an entity receives a damage event, after passing damage filters, etc.\r\n```lua\rent: Entity\r\n--The entity that took the damage.\r\ndmg: CTakeDamageInfo\r\ntook: boolean\r\n--Whether the entity actually took the damage. (For example, shooting a Strider will generate this event, but it won\'t take bullet damage).\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity\n---@param dmg CTakeDamageInfo\n---@param took boolean'
customsnip = 'Add("PostEntityTakeDamage", "${1:name}", function(ent, dmg, took)\n\t$0\nend)'

[PostGamemodeLoaded]
type = 'interface'
description = 'Called after the gamemode has loaded.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("PostGamemodeLoaded", "${1:name}", function()\n\t$0\nend)'

[PostPlayerDeath]
type = 'interface'
description = 'Called right after <page>GM:DoPlayerDeath</page>, <page>GM:PlayerDeath</page> and <page>GM:PlayerSilentDeath</page>.\r\n\r\nThis hook will be called for all deaths, including <page>Player:KillSilent</page>\r\n\r\n<note>The player is considered dead when this is hook is called, <page>Player:Alive</page> will return false.</note>\r\n```lua\rply: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("PostPlayerDeath", "${1:name}", function(ply)\n\t$0\nend)'

[PostPlayerDraw]
type = 'interface'
description = 'Called after the player was drawn.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n```lua\rply: Player\r\n--The player that was drawn.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player'
customsnip = 'Add("PostPlayerDraw", "${1:name}", function(ply)\n\t$0\nend)'

[PostProcessPermitted]
type = 'interface'
description = 'Allows you to suppress post processing effect drawing.\r\n```lua\rppeffect: string\r\n--The classname of Post Processing effect\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ppeffect string'
customsnip = 'Add("PostProcessPermitted", "${1:name}", function(ppeffect)\n\t$0\nend)'

[PostRender]
type = 'interface'
description = 'Called after the frame has been rendered.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostRender", "${1:name}", function()\n\t$0\nend)'

[PostRenderVGUI]
type = 'interface'
description = 'Called after the VGUI has been drawn.\r\n\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostRenderVGUI", "${1:name}", function()\n\t$0\nend)'

[PreCleanupMap]
type = 'interface'
description = 'Called right before the map cleans up (usually because <page>game.CleanUpMap</page> was called)\r\n\r\nSee also <page>GM:PostCleanupMap</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("PreCleanupMap", "${1:name}", function()\n\t$0\nend)'

[PreDrawEffects]
type = 'interface'
description = 'Called just after <page>GM:PreDrawViewModel</page> and can technically be considered "PostDrawAllViewModels".\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreDrawEffects", "${1:name}", function()\n\t$0\nend)'

[PreDrawHalos]
type = 'interface'
description = 'Called before rendering the halos. This is the place to call <page>halo.Add</page>. This hook is actually running inside of <page>GM:PostDrawEffects</page>.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreDrawHalos", "${1:name}", function()\n\t$0\nend)'

[PreDrawHUD]
type = 'interface'
description = 'Called just after <page>GM:PostDrawEffects</page>. Drawing anything in it seems to work incorrectly.\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreDrawHUD", "${1:name}", function()\n\t$0\nend)'

[PreDrawOpaqueRenderables]
type = 'interface'
description = 'Called before all opaque entities are drawn.\r\n\r\nSee also <page>GM:PreDrawTranslucentRenderables</page> and  <page>GM:PostDrawOpaqueRenderables</page>.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n```lua\risDrawingDepth: boolean\r\n--Whether the current draw is writing depth.\r\nisDrawSkybox: boolean\r\n--Whether the current draw is drawing the skybox.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param isDrawingDepth boolean\n---@param isDrawSkybox boolean'
customsnip = 'Add("PreDrawOpaqueRenderables", "${1:name}", function(isDrawingDepth, isDrawSkybox)\n\t$0\nend)'

[PreDrawPlayerHands]
type = 'interface'
description = 'Called before the player hands are drawn.\r\n```lua\rhands: Entity\r\n--This is the gmod_hands entity before it is drawn.\r\nvm: Entity\r\n--This is the view model entity before it is drawn.\r\nply: Player\r\n--The the owner of the view model.\r\nweapon: Weapon\r\n--This is the weapon that is from the view model.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param hands Entity\n---@param vm Entity\n---@param ply Player\n---@param weapon Weapon'
customsnip = 'Add("PreDrawPlayerHands", "${1:name}", function(hands, vm, ply, weapon)\n\t$0\nend)'

[PreDrawSkyBox]
type = 'interface'
description = 'Called before the sky box is drawn.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreDrawSkyBox", "${1:name}", function()\n\t$0\nend)'

[PreDrawTranslucentRenderables]
type = 'interface'
description = 'Called before all the translucent entities are drawn.\r\n\r\nSee also <page>GM:PreDrawOpaqueRenderables</page> and  <page>GM:PostDrawTranslucentRenderables</page>.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n<bug issue="3295">This is still called when r_drawentities or r_drawopaquerenderables is disabled.</bug>\r\n<bug issue="3296">This is not called when r_drawtranslucentworld is disabled.</bug>\r\n```lua\risDrawingDepth: boolean\r\n--Whether the current draw is writing depth.\r\nisDrawSkybox: boolean\r\n--Whether the current draw is drawing the skybox.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param isDrawingDepth boolean\n---@param isDrawSkybox boolean'
customsnip = 'Add("PreDrawTranslucentRenderables", "${1:name}", function(isDrawingDepth, isDrawSkybox)\n\t$0\nend)'

[PreDrawViewModel]
type = 'interface'
description = 'Called before the view model has been drawn. This hook by default also calls this on weapons, so you can use <page>WEAPON:PreDrawViewModel</page>.\r\n\r\nYou can use <page>GM:PreDrawEffects</page> as a "PostDrawViewModel" hook as it is called just after the view model(s) are drawn.\r\n\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n```lua\rvm: Entity\r\n--This is the view model entity before it is drawn. On server-side, this entity is the predicted view model.\r\nply: Player\r\n--The the owner of the view model.\r\nweapon: Weapon\r\n--This is the weapon that is from the view model.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param vm Entity\n---@param ply Player\n---@param weapon Weapon'
customsnip = 'Add("PreDrawViewModel", "${1:name}", function(vm, ply, weapon)\n\t$0\nend)'

[PreDrawViewModels]
type = 'interface'
description = 'Called before view models and entities with `RENDERGROUP_VIEWMODEL` are drawn.\r\n\r\nYou can use <page>GM:PreDrawEffects</page> as a `PostDrawViewModel` hook as it is called just after the view model(s) are drawn.\r\n<rendercontext hook="true" type="3D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreDrawViewModels", "${1:name}", function()\n\t$0\nend)'

[PreGamemodeLoaded]
type = 'interface'
description = 'Called before the gamemode is loaded.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("PreGamemodeLoaded", "${1:name}", function()\n\t$0\nend)'

[PrePlayerDraw]
type = 'interface'
description = 'Called before the player is drawn.\r\n```lua\rplayer: Player\r\n--The player that is about to be drawn.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param player Player'
customsnip = 'Add("PrePlayerDraw", "${1:name}", function(player)\n\t$0\nend)'

[PreRender]
type = 'interface'
description = 'Called before the renderer is about to start rendering the next frame.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreRender", "${1:name}", function()\n\t$0\nend)'

[PreventScreenClicks]
type = 'interface'
description = 'This will prevent `IN_ATTACK` from sending to server when player tries to shoot from C menu.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreventScreenClicks", "${1:name}", function()\n\t$0\nend)'

[PropBreak]
type = 'interface'
description = 'Called when a prop has been destroyed.\r\n```lua\rattacker: Player\r\n--The person who broke the prop.\r\nprop: Entity\r\n--The entity that has been broken by the attacker.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param attacker Player\n---@param prop Entity'
customsnip = 'Add("PropBreak", "${1:name}", function(attacker, prop)\n\t$0\nend)'

[RenderScene]
type = 'interface'
description = 'Render the scene. Used by the "Stereoscopy" Post-processing effect.\r\n\r\n<note>Materials rendered in this hook require $ignorez parameter to draw properly.</note>\r\n```lua\rorigin: Vector\r\n--View origin\r\nangles: Angle\r\n--View angles\r\nfov: number\r\n--View FOV\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param origin Vector\n---@param angles Angle\n---@param fov number'
customsnip = 'Add("RenderScene", "${1:name}", function(origin, angles, fov)\n\t$0\nend)'

[RenderScreenspaceEffects]
type = 'interface'
description = 'Used to render post processing effects.\r\n\r\n<rendercontext hook="true" type="2D"></rendercontext>\r\n\r\n**Scope:** Client'
customsnip = 'Add("RenderScreenspaceEffects", "${1:name}", function()\n\t$0\nend)'

[Restored]
type = 'interface'
description = 'Called when the game is reloaded from a Source Engine save system ( not the Sandbox saves or dupes ).\r\n\r\nSee <page>GM:Saved</page> for a hook that is called when such a save file is created.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Restored", "${1:name}", function()\n\t$0\nend)'

[Saved]
type = 'interface'
description = 'Called when the game is saved using the Source Engine save system (not the Sandbox saves or dupes).\r\n\r\nSee <page>GM:Restored</page> for a hook that is called when such a save file is loaded.\r\n\r\nSee also the <page>saverestore</page> for relevant functions.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Saved", "${1:name}", function()\n\t$0\nend)'

[ScaleNPCDamage]
type = 'interface'
description = 'Called when an NPC takes damage.\r\n\r\n<note>This hook is called only when a specific hit group of the NPC is hit. In cases where the hitgroup doesn\'t matter, you should use <page>GM:EntityTakeDamage</page> instead!</note>\r\n```lua\rnpc: NPC\r\n--The NPC that takes damage\r\nhitgroup: number\r\n--The hitgroup (hitbox) enum where the NPC took damage. See <page>Enums/HITGROUP</page>\r\ndmginfo: CTakeDamageInfo\r\n--Damage info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param npc NPC\n---@param hitgroup number\n---@param dmginfo CTakeDamageInfo'
customsnip = 'Add("ScaleNPCDamage", "${1:name}", function(npc, hitgroup, dmginfo)\n\t$0\nend)'

[ScalePlayerDamage]
type = 'interface'
description = 'This hook allows you to change how much damage a player receives when one takes damage to a specific body part.\r\n\r\n<note>This is called only for bullet damage a player receives, you should use <page>GM:EntityTakeDamage</page> instead if you need to detect *ALL* damage.</note>\r\n```lua\rply: Player\r\n--The player taking damage.\r\nhitgroup: number\r\n--The hitgroup where the player took damage. See <page>Enums/HITGROUP</page>\r\ndmginfo: CTakeDamageInfo\r\n--The damage info.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param hitgroup number\n---@param dmginfo CTakeDamageInfo'
customsnip = 'Add("ScalePlayerDamage", "${1:name}", function(ply, hitgroup, dmginfo)\n\t$0\nend)'

[ScoreboardHide]
type = 'interface'
description = 'Called when player released the scoreboard button. ( TAB by default )\r\n\r\n**Scope:** Client'
customsnip = 'Add("ScoreboardHide", "${1:name}", function()\n\t$0\nend)'

[ScoreboardShow]
type = 'interface'
description = 'Called when player presses the scoreboard button. ( TAB by default )\r\n\r\n**Scope:** Client'
customsnip = 'Add("ScoreboardShow", "${1:name}", function()\n\t$0\nend)'

[SetPlayerSpeed]
type = 'interface'
description = 'Sets player run and sprint speeds.\r\n\r\n<warning>This is not a hook. Treat this as a utility function to set the player\'s speed.</warning>\r\n```lua\rply: Player\r\n--The player to set the speed of.\r\nwalkSpeed: number\r\n--The walk speed.\r\nrunSpeed: number\r\n--The run speed.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param walkSpeed number\n---@param runSpeed number'
customsnip = 'Add("SetPlayerSpeed", "${1:name}", function(ply, walkSpeed, runSpeed)\n\t$0\nend)'

[SetupMove]
type = 'interface'
description = 'SetupMove is called before the engine process movements. This allows us to override the players movement.\r\n\r\nSee <page>Game Movement</page> for an explanation on the move system.\r\n```lua\rply: Player\r\n--The player whose movement we are about to process\r\nmv: CMoveData\r\n--The move data to override/use\r\ncmd: CUserCmd\r\n--The command data\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param mv CMoveData\n---@param cmd CUserCmd'
customsnip = 'Add("SetupMove", "${1:name}", function(ply, mv, cmd)\n\t$0\nend)'

[SetupPlayerVisibility]
type = 'interface'
description = 'Allows you to add extra positions to the player\'s PVS. This is the place to call <page>Global.AddOriginToPVS</page>.\r\n```lua\rply: Player\r\n--The player\r\nviewEntity: Entity\r\n--Players <page>Player:GetViewEntity</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param viewEntity Entity'
customsnip = 'Add("SetupPlayerVisibility", "${1:name}", function(ply, viewEntity)\n\t$0\nend)'

[SetupSkyboxFog]
type = 'interface'
description = 'Allows you to use render.Fog* functions to manipulate skybox fog.\r\n```lua\rscale: number\r\n--The scale of 3D skybox\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param scale number'
customsnip = 'Add("SetupSkyboxFog", "${1:name}", function(scale)\n\t$0\nend)'

[SetupWorldFog]
type = 'interface'
description = 'Allows you to use render.Fog* functions to manipulate world fog.\r\n\r\n**Scope:** Client'
customsnip = 'Add("SetupWorldFog", "${1:name}", function()\n\t$0\nend)'

[ShouldCollide]
type = 'interface'
description = 'Called to decide whether a pair of entities should collide with each other. This is only called if <page>Entity:SetCustomCollisionCheck</page> was used on one or both entities.\r\n\r\nWhere applicable, consider using <page>constraint.NoCollide</page> instead - it is considerably easier to use.\r\n\r\n<warning>This hook **must** return the same value consistently for the same pair of entities. If an entity changed in such a way that its collision rules change, you **must** call <page>Entity:CollisionRulesChanged</page> on that entity immediately - **not in this hook.**</warning>\r\n\r\n<bug issue="642">This hook can cause all physics to break under certain conditions.</bug>\r\n```lua\rent1: Entity\r\n--The first entity in the collision poll.\r\nent2: Entity\r\n--The second entity in the collision poll.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent1 Entity\n---@param ent2 Entity'
customsnip = 'Add("ShouldCollide", "${1:name}", function(ent1, ent2)\n\t$0\nend)'

[ShouldDrawLocalPlayer]
type = 'interface'
description = 'Called to determine if the <page>Global.LocalPlayer</page> should be drawn.\r\n\r\n<bug issue="3092">Due to an [optimization](https://garry.tv/2012/10/30/optimising-gmod/), this hook is only called once per frame.\r\n\r\nThis is problematic if you need to have the player drawn only in certain contexts, such as within <page>render.RenderView</page> or based on the render target. As a workaround, you can call <page>cam.Start3D</page> and <page>cam.End3D</page> within this hook to force the engine to call it every time.</bug>\r\n\r\n<note>If you\'re using this hook to draw a player for a <page>GM:CalcView</page> hook, then you may want to consider using the drawviewer variable you can use in your <page>Structures/CamData</page> table instead.</note>\r\n```lua\rply: Player\r\n--The player\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player'
customsnip = 'Add("ShouldDrawLocalPlayer", "${1:name}", function(ply)\n\t$0\nend)'

[ShowHelp]
type = 'interface'
description = 'Called when a player executes gm_showhelp console command. ( Default bind is F1 )\r\n```lua\rply: Player\r\n--Player who executed the command\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("ShowHelp", "${1:name}", function(ply)\n\t$0\nend)'

[ShowSpare1]
type = 'interface'
description = 'Called when a player executes gm_showspare1 console command. ( Default bind is F3 )\r\n```lua\rply: Player\r\n--Player who executed the command\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("ShowSpare1", "${1:name}", function(ply)\n\t$0\nend)'

[ShowSpare2]
type = 'interface'
description = 'Called when a player executes gm_showspare2 console command. ( Default bind is F4 )\r\n```lua\rply: Player\r\n--Player who executed the command\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("ShowSpare2", "${1:name}", function(ply)\n\t$0\nend)'

[ShowTeam]
type = 'interface'
description = 'Called when a player executes gm_showteam console command. ( Default bind is F2 )\r\n```lua\rply: Player\r\n--Player who executed the command\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("ShowTeam", "${1:name}", function(ply)\n\t$0\nend)'

[ShutDown]
type = 'interface'
description = 'Called whenever the Lua environment is about to be shut down, for example on map change, or when the server is going to shut down.\r\n<warning><page>Player:SteamID</page>, <page>Player:SteamID64</page>, and the like will return nil for the listen host here but work fine for other players.</warning>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("ShutDown", "${1:name}", function()\n\t$0\nend)'

[SpawniconGenerated]
type = 'interface'
description = 'Called when spawn icon is generated.\r\n```lua\rlastmodel: string\r\n--File path of previously generated model.\r\nimagename: string\r\n--File path of the generated icon.\r\nmodelsleft: number\r\n--Amount of models left to generate.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param lastmodel string\n---@param imagename string\n---@param modelsleft number'
customsnip = 'Add("SpawniconGenerated", "${1:name}", function(lastmodel, imagename, modelsleft)\n\t$0\nend)'

[StartChat]
type = 'interface'
description = 'Runs when the user tries to open the chat box.\r\n\r\n<bug issue="855">Returning true won\'t stop the chatbox from taking VGUI focus.</bug>\r\n```lua\risTeamChat: boolean\r\n--Whether the message was sent through team chat.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param isTeamChat boolean'
customsnip = 'Add("StartChat", "${1:name}", function(isTeamChat)\n\t$0\nend)'

[StartCommand]
type = 'interface'
description = 'Allows you to change the players inputs before they are processed by the server.\r\n\r\n\r\n\r\n\r\nThis is basically a shared version of <page>GM:CreateMove</page>.\r\n\r\n<note>This function is also called for bots, making it the best solution to control them so far</note>\r\n\r\n<note>This hook is predicted, but not by usual means, this hook is called when a <page>CUserCmd</page> is generated on the client, and on the server when it is received, so it is necessary for this hook to be called clientside even on singleplayer</note>\r\n```lua\rply: Player\r\n--The player\r\nucmd: CUserCmd\r\n--The usercommand\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param ucmd CUserCmd'
customsnip = 'Add("StartCommand", "${1:name}", function(ply, ucmd)\n\t$0\nend)'

[StartEntityDriving]
type = 'interface'
description = 'Called right before an entity starts driving. Overriding this hook will cause it to not call <page>drive.Start</page> and the player will not begin driving the entity.\r\n```lua\rent: Entity\r\n--The entity that is going to be driven\r\nply: Player\r\n--The player that is going to drive the entity\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ent Entity\n---@param ply Player'
customsnip = 'Add("StartEntityDriving", "${1:name}", function(ent, ply)\n\t$0\nend)'

[StartGame]
type = 'interface'
description = 'Called when you start a new game via the menu.\r\n\r\n**Scope:** Client'
customsnip = 'Add("StartGame", "${1:name}", function()\n\t$0\nend)'

[Think]
type = 'interface'
description = 'Called every frame on client and server. This will be the same as <page>GM:Tick</page> on the server when there is no lag, but will only be called once every processed server frame during lag.\r\n\r\nSee <page>GM:Tick</page> for a hook that runs every tick on both the client and server.\r\n\r\n<note>This hook **WILL NOT** run if the server is empty, unless you set the <page>ConVar</page> `sv_hibernate_think` to 1</note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Think", "${1:name}", function()\n\t$0\nend)'

[Tick]
type = 'interface'
description = 'Called every server tick. Serverside, this is similar to <page>GM:Think</page>.\r\n\r\n<note>This hook **WILL NOT** run if the server is empty, unless you set the <page>ConVar</page> `sv_hibernate_think` to 1</note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Tick", "${1:name}", function()\n\t$0\nend)'

[TranslateActivity]
type = 'interface'
description = 'Allows you to translate player activities.\r\n```lua\rply: Player\r\n--The player\r\nact: number\r\n--The activity. See <page>Enums/ACT</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param act number'
customsnip = 'Add("TranslateActivity", "${1:name}", function(ply, act)\n\t$0\nend)'

[UpdateAnimation]
type = 'interface'
description = 'Animation updates (pose params etc) should be done here.\r\n```lua\rply: Player\r\n--The player to update the animation info for.\r\nvelocity: Vector\r\n--The player\'s velocity.\r\nmaxSeqGroundSpeed: number\r\n--Speed of the animation - used for playback rate scaling.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param velocity Vector\n---@param maxSeqGroundSpeed number'
customsnip = 'Add("UpdateAnimation", "${1:name}", function(ply, velocity, maxSeqGroundSpeed)\n\t$0\nend)'

[VariableEdited]
type = 'interface'
description = 'Called when a variable is edited on an Entity (called by Edit Properties... menu). See <page>Editable Entities</page> for more information.\r\n```lua\rent: Entity\r\n--The entity being edited\r\nply: Player\r\n--The player doing the editing\r\nkey: string\r\n--The name of the variable\r\nval: string\r\n--The new value, as a string which will later be converted to its appropriate type\r\neditor: table\r\n--The edit table defined in <page>Entity:NetworkVar</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity\n---@param ply Player\n---@param key string\n---@param val string\n---@param editor table'
customsnip = 'Add("VariableEdited", "${1:name}", function(ent, ply, key, val, editor)\n\t$0\nend)'

[VehicleMove]
type = 'interface'
description = 'Called when you are driving a vehicle. This hook works just like <page>GM:Move</page>.\r\n\r\nThis hook is called before <page>GM:Move</page> and will be called when <page>GM:PlayerTick</page> is not.\r\n```lua\rply: Player\r\n--Player who is driving the vehicle\r\nveh: Vehicle\r\n--The vehicle being driven\r\nmv: CMoveData\r\n--Move data\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param veh Vehicle\n---@param mv CMoveData'
customsnip = 'Add("VehicleMove", "${1:name}", function(ply, veh, mv)\n\t$0\nend)'

[VGUIMousePressAllowed]
type = 'interface'
description = 'Called when user clicks on a VGUI panel.\r\n```lua\rbutton: number\r\n--The button that was pressed, see <page>Enums/MOUSE</page>\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param button number'
customsnip = 'Add("VGUIMousePressAllowed", "${1:name}", function(button)\n\t$0\nend)'

[VGUIMousePressed]
type = 'interface'
description = 'Called when a mouse button is pressed on a VGUI element or menu.\r\n```lua\rpnl: Panel\r\n--Panel that currently has focus.\r\nmouseCode: number\r\n--The key that the player pressed using <page>Enums/MOUSE</page>.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param pnl Panel\n---@param mouseCode number'
customsnip = 'Add("VGUIMousePressed", "${1:name}", function(pnl, mouseCode)\n\t$0\nend)'

[WeaponEquip]
type = 'interface'
description = 'Called as a weapon entity is picked up by a player.\r\n\r\nSee also <page>GM:PlayerDroppedWeapon</page>.\r\n\r\n<note>At the time when this hook is called <page>Entity:GetOwner</page> will return NULL. The owner is set on the next frame</note>\r\n<note>This will not be called when picking up a weapon you already have as the weapon will be removed and <page>WEAPON:EquipAmmo</page> will be called instead</note>\r\n```lua\rweapon: Weapon\r\n--The equipped weapon.\r\nowner: Player\r\n--The player that is picking up the weapon.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param weapon Weapon\n---@param owner Player'
customsnip = 'Add("WeaponEquip", "${1:name}", function(weapon, owner)\n\t$0\nend)'

[WorkshopDownloadedFile]
type = 'interface'
description = 'Called when an addon from the Steam workshop finishes downloading. Used by default to update details on the workshop downloading panel.\r\n```lua\rid: number\r\n--Workshop ID of addon.\r\ntitle: string\r\n--Name of addon.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param id number\n---@param title string'
customsnip = 'Add("WorkshopDownloadedFile", "${1:name}", function(id, title)\n\t$0\nend)'

[WorkshopDownloadFile]
type = 'interface'
description = 'Called when an addon from the Steam workshop begins downloading. Used by default to place details on the workshop downloading panel.\r\n```lua\rid: number\r\n--Workshop ID of addon.\r\nimageID: number\r\n--ID of addon\'s preview image.\r\n\r\n\r\n\r\nFor example, for **Extended Spawnmenu** addon, the image URL is\r\n\r\n```\r\nhttp://cloud-4.steamusercontent.com/ugc/702859018846106764/9E7E1946296240314751192DA0AD15B6567FF92D/\r\n```\r\n\r\nSo, the value of this argument would be **702859018846106764**.\r\ntitle: string\r\n--Name of addon.\r\nsize: number\r\n--File size of addon in bytes.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param id number\n---@param imageID number\n---@param title string\n---@param size number'
customsnip = 'Add("WorkshopDownloadFile", "${1:name}", function(id, imageID, title, size)\n\t$0\nend)'

[WorkshopDownloadProgress]
type = 'interface'
description = 'Called while an addon from the Steam workshop is downloading. Used by default to update details on the fancy workshop download panel.\r\n```lua\rid: number\r\n--Workshop ID of addon.\r\nimageID: number\r\n--ID of addon\'s preview image.\r\n\r\n\r\n\r\nFor example, for **Extended Spawnmenu** addon, the image URL is\r\n\r\n```\r\nhttp://cloud-4.steamusercontent.com/ugc/702859018846106764/9E7E1946296240314751192DA0AD15B6567FF92D/\r\n```\r\n\r\nSo, the value of this argument would be **702859018846106764**.\r\ntitle: string\r\n--Name of addon.\r\ndownloaded: number\r\n--Current bytes of addon downloaded.\r\nexpected: number\r\n--Expected file size of addon in bytes.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param id number\n---@param imageID number\n---@param title string\n---@param downloaded number\n---@param expected number'
customsnip = 'Add("WorkshopDownloadProgress", "${1:name}", function(id, imageID, title, downloaded, expected)\n\t$0\nend)'

[WorkshopDownloadTotals]
type = 'interface'
description = 'Called after <page>GM:WorkshopStart</page>.\r\n```lua\rremain: number\r\n--Remaining addons to download\r\ntotal: number\r\n--Total addons needing to be downloaded\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param remain number\n---@param total number'
customsnip = 'Add("WorkshopDownloadTotals", "${1:name}", function(remain, total)\n\t$0\nend)'

[WorkshopEnd]
type = 'interface'
description = 'Called when downloading content from Steam workshop ends. Used by default to hide fancy workshop downloading panel.\r\n\r\n**Scope:** Client'
customsnip = 'Add("WorkshopEnd", "${1:name}", function()\n\t$0\nend)'

[WorkshopExtractProgress]
type = 'interface'
description = 'Called while an addon from the Steam workshop is extracting. Used by default to update details on the fancy workshop download panel.\r\n```lua\rid: number\r\n--Workshop ID of addon.\r\nImageID: number\r\n--ID of addon\'s preview image.\r\n\r\n\r\n\r\nFor example, for **Extended Spawnmenu** addon, the image URL is\r\n\r\n```\r\nhttp://cloud-4.steamusercontent.com/ugc/702859018846106764/9E7E1946296240314751192DA0AD15B6567FF92D/\r\n```\r\n\r\nSo, the value of this argument would be **702859018846106764**.\r\ntitle: string\r\n--Name of addon.\r\npercent: number\r\n--Current bytes of addon extracted.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param id number\n---@param ImageID number\n---@param title string\n---@param percent number'
customsnip = 'Add("WorkshopExtractProgress", "${1:name}", function(id, ImageID, title, percent)\n\t$0\nend)'

[WorkshopStart]
type = 'interface'
description = 'Called when downloading content from Steam workshop begins. Used by default to show fancy workshop downloading panel.\r\n\r\nThe order of Workshop hooks is this:\r\n* WorkshopStart\r\n* WorkshopDownloadTotals\r\n* * These are called for each new item:\r\n*** WorkshopDownloadFile\r\n*** WorkshopDownloadProgress - This is called until the file is finished\r\n*** WorkshopDownloadedFile\r\n* WorkshopEnd\r\n\r\n**Scope:** Client'
customsnip = 'Add("WorkshopStart", "${1:name}", function()\n\t$0\nend)'

[WorkshopSubscriptionsProgress]
type = 'interface'
description = '<internal></internal>\r\nCalled by the engine when the game initially fetches subscriptions to be displayed on the bottom of the main menu screen.\r\n```lua\rnum: number\r\n--Amount of subscribed addons that have info retrieved.\r\nmax: number\r\n--Total amount of subscribed addons that need their info retrieved.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param num number\n---@param max number'
customsnip = 'Add("WorkshopSubscriptionsProgress", "${1:name}", function(num, max)\n\t$0\nend)'

[BehaveStart]
type = 'interface'
description = 'Called to initialize the behaviour.\r\n\r\nThis is called automatically when the NextBot is created, you should not call it manually.\r\n\r\n<note>You shouldn\'t override this unless you know what you are doing - it\'s used to kick off the <page>coroutine</page> that runs the bot\'s behaviour. See <page>NEXTBOT:RunBehaviour</page> instead.</note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("BehaveStart", "${1:name}", function()\n\t$0\nend)'

[BehaveUpdate]
type = 'interface'
description = 'Called to update the bot\'s behaviour.\r\n```lua\rinterval: number\r\n--How long since the last update\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param interval number'
customsnip = 'Add("BehaveUpdate", "${1:name}", function(interval)\n\t$0\nend)'

[BodyUpdate]
type = 'interface'
description = 'Called to update the bot\'s animation.\r\n\r\n**Scope:** Server'
customsnip = 'Add("BodyUpdate", "${1:name}", function()\n\t$0\nend)'

[OnContact]
type = 'interface'
description = 'Called when the nextbot touches another entity.\r\n```lua\rent: Entity\r\n--The entity the nextbot came in contact with.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("OnContact", "${1:name}", function(ent)\n\t$0\nend)'

[OnEntitySight]
type = 'interface'
description = 'Called when the nextbot NPC sees another Nextbot NPC or a Player.\r\n<note>This hook will only run after <page>NextBot:SetFOV</page> or other vision related function is called on the nextbot. See <page>NextBot:IsAbleToSee</page> for more details.</note>\r\n```lua\rent: Entity\r\n--the entity that was seen\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("OnEntitySight", "${1:name}", function(ent)\n\t$0\nend)'

[OnEntitySightLost]
type = 'interface'
description = 'Called when the nextbot NPC loses sight of another Nextbot NPC or a Player.\r\n<note>This hook will only run after <page>NextBot:SetFOV</page> or other vision related function is called on the nextbot. See <page>NextBot:IsAbleToSee</page> for more details.</note>\r\n```lua\rent: Entity\r\n--the entity that we lost sight of\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("OnEntitySightLost", "${1:name}", function(ent)\n\t$0\nend)'

[OnIgnite]
type = 'interface'
description = 'Called when the bot is ignited.\r\n\r\n**Scope:** Server'
customsnip = 'Add("OnIgnite", "${1:name}", function()\n\t$0\nend)'

[OnInjured]
type = 'interface'
description = 'Called when the bot gets hurt. This is a good place to play hurt sounds or voice lines.\r\n```lua\rinfo: CTakeDamageInfo\r\n--The damage info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param info CTakeDamageInfo'
customsnip = 'Add("OnInjured", "${1:name}", function(info)\n\t$0\nend)'

[OnKilled]
type = 'interface'
description = 'Called when the bot gets killed.\r\n```lua\rinfo: CTakeDamageInfo\r\n--The damage info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param info CTakeDamageInfo'
customsnip = 'Add("OnKilled", "${1:name}", function(info)\n\t$0\nend)'

[OnLandOnGround]
type = 'interface'
description = 'Called when the bot\'s feet return to the ground.\r\n```lua\rent: Entity\r\n--The entity the nextbot has landed on.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("OnLandOnGround", "${1:name}", function(ent)\n\t$0\nend)'

[OnLeaveGround]
type = 'interface'
description = 'Called when the bot\'s feet leave the ground - for whatever reason.\r\n```lua\rent: Entity\r\n--The entity the bot "jumped" from.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ent Entity'
customsnip = 'Add("OnLeaveGround", "${1:name}", function(ent)\n\t$0\nend)'

[OnNavAreaChanged]
type = 'interface'
description = 'Called when the nextbot enters a new navigation area.\r\n```lua\rold: CNavArea\r\n--The navigation area the bot just left\r\nnew: CNavArea\r\n--The navigation area the bot just entered\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param old CNavArea\n---@param new CNavArea'
customsnip = 'Add("OnNavAreaChanged", "${1:name}", function(old, new)\n\t$0\nend)'

[OnOtherKilled]
type = 'interface'
description = 'Called when someone else or something else has been killed.\r\n```lua\rvictim: Entity\r\n--The victim that was killed\r\ninfo: CTakeDamageInfo\r\n--The damage info\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param victim Entity\n---@param info CTakeDamageInfo'
customsnip = 'Add("OnOtherKilled", "${1:name}", function(victim, info)\n\t$0\nend)'

[OnStuck]
type = 'interface'
description = 'Called when the bot thinks it is stuck.\r\n\r\n**Scope:** Server'
customsnip = 'Add("OnStuck", "${1:name}", function()\n\t$0\nend)'

[OnTraceAttack]
type = 'interface'
description = 'Called when a trace attack is done against the nextbot, allowing override of the damage being dealt by altering the <page>CTakeDamageInfo</page>.\r\n\r\nThis is called before <page>NEXTBOT:OnInjured</page>.\r\n```lua\rinfo: CTakeDamageInfo\r\n--The damage info\r\ndir: Vector\r\n--The direction the damage goes in\r\ntrace: table\r\n--The <page>Structures/TraceResult</page> of the attack, containing the hitgroup.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param info CTakeDamageInfo\n---@param dir Vector\n---@param trace table'
customsnip = 'Add("OnTraceAttack", "${1:name}", function(info, dir, trace)\n\t$0\nend)'

[OnUnStuck]
type = 'interface'
description = 'Called when the bot thinks it is un-stuck.\r\n\r\n**Scope:** Server'
customsnip = 'Add("OnUnStuck", "${1:name}", function()\n\t$0\nend)'

[RunBehaviour]
type = 'interface'
description = 'A hook called to process nextbot logic.\r\n\r\nThis hook runs in a <page>coroutine</page> by default. It will only be called if <page>NEXTBOT:BehaveStart</page> is not overriden.\r\n\r\n**Scope:** Server'
customsnip = 'Add("RunBehaviour", "${1:name}", function()\n\t$0\nend)'

[ActionSignal]
type = 'interface'
description = 'Called whenever a panel receives a command signal from one of its children.\r\n\r\nThis hook is called when using <page>Panel:Command</page>, when clicking a <page>Button</page> with <page>Panel:SetCommand</page> set, and when clicking text within a <page>RichText</page> panel that is marked as click-able.\r\n```lua\rsignalName: string\r\n--The name of the signal, usually the sender of the signal or the command name.\r\nsignalValue: string\r\n--The value of the signal, usually a command argument.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param signalName string\n---@param signalValue string'
customsnip = 'Add("ActionSignal", "${1:name}", function(signalName, signalValue)\n\t$0\nend)'

[AnimationThink]
type = 'interface'
description = 'Called every frame unless <page>Panel:IsVisible</page> is set to false. Similar to <page>PANEL:Think</page>, but can be disabled by <page>Panel:SetAnimationEnabled</page> as explained below.\r\n\r\nIf you are overriding this, you must call <page>Panel:AnimationThinkInternal</page> every frame, else animations will cease to work.\r\n\r\nIf you want to "disable" this hook with <page>Panel:SetAnimationEnabled</page>, you must call it after defining this hook. Once disabled, a custom hook **will not** be re-enabled by <page>Panel:SetAnimationEnabled</page> again - the hook will have to be re-defined.\r\n\r\n**Scope:** Client'
customsnip = 'Add("AnimationThink", "${1:name}", function()\n\t$0\nend)'

[ApplySchemeSettings]
type = 'interface'
description = 'Called whenever the panel should apply its scheme (colors, fonts, style).\r\n\r\nIt is called a few frames after Panel\'s creation once.\r\n\r\n**Scope:** Client'
customsnip = 'Add("ApplySchemeSettings", "${1:name}", function()\n\t$0\nend)'

[DragHoverClick]
type = 'interface'
description = 'Called when an object is dragged and hovered over this panel for 0.1 seconds.\r\n\r\nThis is used by <page>DPropertySheet</page> and <page>DTree</page>, for example to open a tab or expand a node when an object is hovered over it.\r\n```lua\rhoverTime: number\r\n--The time the object was hovered over this panel.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param hoverTime number'
customsnip = 'Add("DragHoverClick", "${1:name}", function(hoverTime)\n\t$0\nend)'

[DroppedOn]
type = 'interface'
description = 'Called when this panel is dropped onto another panel.\r\n\r\nOnly works for panels derived from <page>DDragBase</page>.\r\n```lua\rpnl: Panel\r\n--The panel we are dropped onto\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param pnl Panel'
customsnip = 'Add("DroppedOn", "${1:name}", function(pnl)\n\t$0\nend)'

[GenerateExample]
type = 'interface'
description = 'Called when the panel should generate example use case / example code to use for this panel. Used in the panel opened by **derma_controls** console command.\r\n```lua\rclass: string\r\n--The classname of the panel to generate example for. This will be the class name of your panel.\r\ndpropertysheet: Panel\r\n--A <page>DPropertySheet</page> to add your example to. See examples below.\r\nwidth: number\r\n--Width of the property sheet?\r\nheight: number\r\n--Width of the property sheet?\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param class string\n---@param dpropertysheet Panel\n---@param width number\n---@param height number'
customsnip = 'Add("GenerateExample", "${1:name}", function(class, dpropertysheet, width, height)\n\t$0\nend)'

[Init]
type = 'interface'
description = 'Called when the panel is created. This is called for each base type that the panel has.\r\n\r\n**Scope:** Client'
customsnip = 'Add("Init", "${1:name}", function()\n\t$0\nend)'

[LoadCookies]
type = 'interface'
description = 'Called after <page>Panel:SetCookieName</page> is called on this panel to apply the just loaded cookie values for this panel.\r\n\r\n**Scope:** Client'
customsnip = 'Add("LoadCookies", "${1:name}", function()\n\t$0\nend)'

[OnActivate]
type = 'interface'
description = '<internal></internal>Called when we are activated during level load. Used by the loading screen panel.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnActivate", "${1:name}", function()\n\t$0\nend)'

[OnChangeTargetURL]
type = 'interface'
description = 'Called by HTML panels when the target URL of the frame has changed, this happens when you hover over a link.\r\n```lua\rtargetURL: string\r\n--New target URL.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param targetURL string'
customsnip = 'Add("OnChangeTargetURL", "${1:name}", function(targetURL)\n\t$0\nend)'

[OnChangeTitle]
type = 'interface'
description = 'Called by HTML panels when the title of the loaded page has been changed.\r\n```lua\rnewTitle: string\r\n--The new title of the page.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param newTitle string'
customsnip = 'Add("OnChangeTitle", "${1:name}", function(newTitle)\n\t$0\nend)'

[OnChildAdded]
type = 'interface'
description = 'Called whenever a child was parented to the panel.\r\n\r\n<bug issue="2759">This is called before the panel\'s metatable is set.</bug>\r\n```lua\rchild: Panel\r\n--The child which was added.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param child Panel'
customsnip = 'Add("OnChildAdded", "${1:name}", function(child)\n\t$0\nend)'

[OnChildRemoved]
type = 'interface'
description = 'Called whenever a child of the panel is about to removed.\r\n```lua\rchild: Panel\r\n--The child which is about to be removed.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param child Panel'
customsnip = 'Add("OnChildRemoved", "${1:name}", function(child)\n\t$0\nend)'

[OnChildViewCreated]
type = 'interface'
description = 'Called by HTML panels when the page attempts to open a new child view (such as a popup or new tab).\r\n```lua\rsourceURL: string\r\n--The URL of the page requesting to create a child.\r\ntargetURL: string\r\n--The URL of the requested child.\r\nisPopup: boolean\r\n--True if the requested view is a popup.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param sourceURL string\n---@param targetURL string\n---@param isPopup boolean'
customsnip = 'Add("OnChildViewCreated", "${1:name}", function(sourceURL, targetURL, isPopup)\n\t$0\nend)'

[OnCursorEntered]
type = 'interface'
description = 'Called whenever the cursor entered the panels bounds.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnCursorEntered", "${1:name}", function()\n\t$0\nend)'

[OnCursorExited]
type = 'interface'
description = 'Called whenever the cursor left the panels bounds.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnCursorExited", "${1:name}", function()\n\t$0\nend)'

[OnCursorMoved]
type = 'interface'
description = 'Called whenever the cursor was moved with the panels bounds.\r\n```lua\rcursorX: number\r\n--The new x position of the cursor relative to the panels origin.\r\ncursorY: number\r\n--The new y position of the cursor relative to the panels origin.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param cursorX number\n---@param cursorY number'
customsnip = 'Add("OnCursorMoved", "${1:name}", function(cursorX, cursorY)\n\t$0\nend)'

[OnDeactivate]
type = 'interface'
description = '<internal></internal>Called when we are deactivated during level load. Used by the loading screen panel.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnDeactivate", "${1:name}", function()\n\t$0\nend)'

[OnDocumentReady]
type = 'interface'
description = 'Called by HTML panels when the panel\'s DOM has been set up. You can run JavaScript in here.\r\n```lua\rurl: string\r\n--The URL of the current page.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param url string'
customsnip = 'Add("OnDocumentReady", "${1:name}", function(url)\n\t$0\nend)'

[OnDrop]
type = 'interface'
description = 'We\'re being dropped on something\r\nWe can create a new panel here and return it, so that instead of dropping us - it drops the new panel instead! We remain where we are!\r\n\r\nOnly works for panels derived from <page>DDragBase</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnDrop", "${1:name}", function()\n\t$0\nend)'

[OnFocusChanged]
type = 'interface'
description = 'Called whenever the panel gained or lost focus.\r\n\r\n<note><page>Panel:HasFocus</page> will only be updated on the next frame and will return the "old" value at the time this hook is run. Same goes for <page>vgui.GetKeyboardFocus</page>.</note>\r\n```lua\rgained: boolean\r\n--If the focus was gained ( true ) or lost ( false )\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param gained boolean'
customsnip = 'Add("OnFocusChanged", "${1:name}", function(gained)\n\t$0\nend)'

[OnKeyCodePressed]
type = 'interface'
description = 'Called whenever a keyboard key was pressed while the panel is focused.\r\n\r\n<bug issue="2886">This is not run for ESC/"cancelselect" binding.</bug>\r\n```lua\rkeyCode: number\r\n--The key code of the pressed key, see <page>Enums/KEY</page>.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param keyCode number'
customsnip = 'Add("OnKeyCodePressed", "${1:name}", function(keyCode)\n\t$0\nend)'

[OnKeyCodeReleased]
type = 'interface'
description = 'Called whenever a keyboard key was released while the panel is focused.\r\n\r\n<bug issue="2886">This is not run for TILDE/"toggleconsole" binding.</bug>\r\n```lua\rkeyCode: number\r\n--The key code of the released key, see <page>Enums/KEY</page>.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param keyCode number'
customsnip = 'Add("OnKeyCodeReleased", "${1:name}", function(keyCode)\n\t$0\nend)'

[OnMousePressed]
type = 'interface'
description = 'Called whenever a mouse key was pressed while the panel is focused.\r\n```lua\rkeyCode: number\r\n--They key code of the key pressed, see <page>Enums/MOUSE</page>.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param keyCode number'
customsnip = 'Add("OnMousePressed", "${1:name}", function(keyCode)\n\t$0\nend)'

[OnMouseReleased]
type = 'interface'
description = 'Called whenever a mouse key was released while the panel is focused.\r\n```lua\rkeyCode: number\r\n--They key code of the key released, see <page>Enums/MOUSE</page>.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param keyCode number'
customsnip = 'Add("OnMouseReleased", "${1:name}", function(keyCode)\n\t$0\nend)'

[OnMouseWheeled]
type = 'interface'
description = 'Called whenever the mouse wheel was used.\r\n```lua\rscrollDelta: number\r\n--The scroll delta, indicating how much the user turned the mouse wheel.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param scrollDelta number'
customsnip = 'Add("OnMouseWheeled", "${1:name}", function(scrollDelta)\n\t$0\nend)'

[OnRemove]
type = 'interface'
description = 'Called when the panel is about to be removed.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnRemove", "${1:name}", function()\n\t$0\nend)'

[OnScreenSizeChanged]
type = 'interface'
description = 'Called when the player\'s screen resolution of the game changes.\r\n\r\n<page>Global.ScrW</page> and <page>Global.ScrH</page> will return the new values when this hook is called.\r\n```lua\roldWidth: number\r\n--The previous width  of the game\'s window\r\noldHeight: number\r\n--The previous height of the game\'s window\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param oldWidth number\n---@param oldHeight number'
customsnip = 'Add("OnScreenSizeChanged", "${1:name}", function(oldWidth, oldHeight)\n\t$0\nend)'

[OnSizeChanged]
type = 'interface'
description = 'Called just after the panel size changes.\r\n\r\nAll size functions will return the new values when this hook is called.\r\n\r\n<warning>Changing the panel size in this hook will cause an infinite loop!</warning>\r\n```lua\rnewWidth: number\r\n--The new width of the panel\r\nnewHeight: number\r\n--The new height of the panel\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param newWidth number\n---@param newHeight number'
customsnip = 'Add("OnSizeChanged", "${1:name}", function(newWidth, newHeight)\n\t$0\nend)'

[OnStartDragging]
type = 'interface'
description = '<internal></internal> Called by <page>dragndrop.StartDragging</page> when the panel starts being dragged.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnStartDragging", "${1:name}", function()\n\t$0\nend)'

[OnStopDragging]
type = 'interface'
description = '<internal></internal> Called by <page>Panel:DragMouseRelease</page> when the panel object is released after being dragged.\r\n\r\n**Scope:** Client'
customsnip = 'Add("OnStopDragging", "${1:name}", function()\n\t$0\nend)'

[Paint]
type = 'interface'
description = 'Called whenever the panel should be drawn.\r\n\r\nYou can create panels with a customized appearance by overriding their Paint() function, which will prevent the default appearance from being drawn.\r\n\r\n<note>Render operations from the <page>surface</page> (and consequentially the <page>draw</page>) are always offset by the global position of this panel, as seen in the example below</note>\r\n\r\n<note>This hook will not run if the panel is completely off the screen. The hook will still run however if any parts of the panel are still on screen.</note>\r\n```lua\rwidth: number\r\n--The panel\'s width.\r\nheight: number\r\n--The panel\'s height.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param width number\n---@param height number'
customsnip = 'Add("Paint", "${1:name}", function(width, height)\n\t$0\nend)'

[PaintOver]
type = 'interface'
description = 'Called whenever the panel and all its children were drawn, return true to override the default drawing.\r\n```lua\rwidth: number\r\n--The panels current width.\r\nheight: number\r\n--The panels current height.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param width number\n---@param height number'
customsnip = 'Add("PaintOver", "${1:name}", function(width, height)\n\t$0\nend)'

[PerformLayout]
type = 'interface'
description = 'Called whenever the panels layout was invalidated. This means all child panels must be re-positioned to fit the possibly new size of this panel.\r\n\r\n<warning>Do **NOT** call this function directly. Use <page>Panel:InvalidateLayout</page> instead!</warning>\r\n```lua\rwidth: number\r\n--The panels current width.\r\nheight: number\r\n--The panels current height.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param width number\n---@param height number'
customsnip = 'Add("PerformLayout", "${1:name}", function(width, height)\n\t$0\nend)'

[PostAutoRefresh]
type = 'interface'
description = 'Only works on elements defined with <page>derma.DefineControl</page> and only if the panel has **AllowAutoRefresh** set to true.\r\n\r\nCalled after <page>derma.DefineControl</page> is called with panel\'s class name.\r\n\r\nSee also <page>PANEL:PreAutoRefresh</page>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostAutoRefresh", "${1:name}", function()\n\t$0\nend)'

[PreAutoRefresh]
type = 'interface'
description = 'Only works on elements defined with <page>derma.DefineControl</page> and only if the panel has **AllowAutoRefresh** set to true.\r\n\r\nCalled when <page>derma.DefineControl</page> is called with this panel\'s class name before applying changes to this panel.\r\n\r\nSee also <page>PANEL:PostAutoRefresh</page>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreAutoRefresh", "${1:name}", function()\n\t$0\nend)'

[TestHover]
type = 'interface'
description = 'Called to test if the panel is being `hovered` by the mouse. This will only be called if the panel\'s parent is being hovered.\r\n```lua\rx: number\r\n--The x coordinate of the cursor, in screen space.\r\ny: number\r\n--The y coordinate of the cursor, in screen space.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param x number\n---@param y number'
customsnip = 'Add("TestHover", "${1:name}", function(x, y)\n\t$0\nend)'

[Think]
type = 'interface'
description = 'Called every frame while <page>Panel:IsVisible</page> is true.\r\n\r\n**Scope:** Client'
customsnip = 'Add("Think", "${1:name}", function()\n\t$0\nend)'

[Death]
type = 'interface'
description = 'Called when the player dies\r\n\r\n**Scope:** Server'
customsnip = 'Add("Death", "${1:name}", function()\n\t$0\nend)'

[FinishMove]
type = 'interface'
description = 'Called from <page>GM:FinishMove</page>.\r\n\r\n<warning>This hook will not work if the current gamemode overrides <page>GM:FinishMove</page> and does not call this hook.</warning>\r\n\r\n<note>This hook is run after the <page>drive.FinishMove</page> has been called.</note>\r\n```lua\rmv: CMoveData\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param mv CMoveData'
customsnip = 'Add("FinishMove", "${1:name}", function(mv)\n\t$0\nend)'

[GetHandsModel]
type = 'interface'
description = 'Called on player spawn to determine which hand model to use\r\n\r\n**Scope:** Client'
customsnip = 'Add("GetHandsModel", "${1:name}", function()\n\t$0\nend)'

[Init]
type = 'interface'
description = 'Called when the class object is created\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Init", "${1:name}", function()\n\t$0\nend)'

[Loadout]
type = 'interface'
description = 'Called on spawn to give the player their default loadout\r\n\r\n**Scope:** Server'
customsnip = 'Add("Loadout", "${1:name}", function()\n\t$0\nend)'

[Move]
type = 'interface'
description = 'Called from <page>GM:Move</page>.\r\n\r\n<warning>This hook will not work if the current gamemode overrides <page>GM:Move</page> and does not call this hook.</warning>\r\n\r\n<note>This hook is run after the <page>drive.Move</page> has been called.</note>\r\n```lua\rmv: CMoveData\r\n--Movement information\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param mv CMoveData'
customsnip = 'Add("Move", "${1:name}", function(mv)\n\t$0\nend)'

[PostDrawViewModel]
type = 'interface'
description = 'Called after the viewmodel has been drawn\r\n```lua\rviewmodel: Entity\r\n--The viewmodel\r\nweapon: Entity\r\n--The weapon\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param viewmodel Entity\n---@param weapon Entity'
customsnip = 'Add("PostDrawViewModel", "${1:name}", function(viewmodel, weapon)\n\t$0\nend)'

[PreDrawViewModel]
type = 'interface'
description = 'Called before the viewmodel is drawn\r\n```lua\rviewmodel: Entity\r\n--The viewmodel\r\nweapon: Entity\r\n--The weapon\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param viewmodel Entity\n---@param weapon Entity'
customsnip = 'Add("PreDrawViewModel", "${1:name}", function(viewmodel, weapon)\n\t$0\nend)'

[SetModel]
type = 'interface'
description = 'Called when we need to set player model from the class.\r\n\r\n<note>This will only be called if you have not overridden <page>GM:PlayerSetModel</page> or call this function from it or anywhere else using <page>player_manager.RunClass</page></note>\r\n\r\n**Scope:** Server'
customsnip = 'Add("SetModel", "${1:name}", function()\n\t$0\nend)'

[SetupDataTables]
type = 'interface'
description = 'Setup the network table accessors.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("SetupDataTables", "${1:name}", function()\n\t$0\nend)'

[Spawn]
type = 'interface'
description = 'Called when the player spawns\r\n\r\n**Scope:** Server'
customsnip = 'Add("Spawn", "${1:name}", function()\n\t$0\nend)'

[StartMove]
type = 'interface'
description = 'Called from <page>GM:CreateMove</page>.\r\n\r\n<warning>This hook will not work if the current gamemode overrides <page>GM:SetupMove</page> and does not call this hook.</warning>\r\n\r\n<note>This hook is run after the <page>drive.StartMove</page> has been called.</note>\r\n```lua\rmv: CMoveData\r\ncmd: CUserCmd\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param mv CMoveData\n---@param cmd CUserCmd'
customsnip = 'Add("StartMove", "${1:name}", function(mv, cmd)\n\t$0\nend)'

[ViewModelChanged]
type = 'interface'
description = 'Called when the player changes their weapon to another one causing their viewmodel model to change\r\n```lua\rviewmodel: Entity\r\n--The viewmodel that is changing\r\nold: string\r\n--The old model\r\nnew: string\r\n--The new model\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param viewmodel Entity\n---@param old string\n---@param new string'
customsnip = 'Add("ViewModelChanged", "${1:name}", function(viewmodel, old, new)\n\t$0\nend)'

[AddGamemodeToolMenuCategories]
type = 'interface'
description = '<internal></internal>\r\n\r\nThis hook is used to add default categories to spawnmenu tool tabs.\r\n\r\nDo not override or hook this function, use <page>SANDBOX:AddToolMenuCategories</page>!\r\n\r\n**Scope:** Client'
customsnip = 'Add("AddGamemodeToolMenuCategories", "${1:name}", function()\n\t$0\nend)'

[AddGamemodeToolMenuTabs]
type = 'interface'
description = '<internal></internal>\r\n\r\nThis hook is used to add default tool tabs to spawnmenu.\r\n\r\nDo not override or hook this function, use <page>SANDBOX:AddToolMenuTabs</page>!\r\n\r\n**Scope:** Client'
customsnip = 'Add("AddGamemodeToolMenuTabs", "${1:name}", function()\n\t$0\nend)'

[AddToolMenuCategories]
type = 'interface'
description = 'This hook is used to add new categories to spawnmenu tool tabs.\r\n\r\n**Scope:** Client'
customsnip = 'Add("AddToolMenuCategories", "${1:name}", function()\n\t$0\nend)'

[AddToolMenuTabs]
type = 'interface'
description = 'This hook is used to add new tool tabs to spawnmenu.\r\n\r\n**Scope:** Client'
customsnip = 'Add("AddToolMenuTabs", "${1:name}", function()\n\t$0\nend)'

[CanArmDupe]
type = 'interface'
description = 'Called when a player attempts to "arm" a duplication with the Duplicator tool. Return false to prevent the player from sending data to server, and to ignore data if it was somehow sent anyway.\r\n```lua\rply: Player\r\n--The player who attempted to arm a dupe.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player'
customsnip = 'Add("CanArmDupe", "${1:name}", function(ply)\n\t$0\nend)'

[CanDrive]
type = 'interface'
description = 'Called when a player attempts to drive a prop via Prop Drive\r\n```lua\rply: Player\r\n--The player who attempted to use Prop Drive.\r\nent: Entity\r\n--The entity the player is attempting to drive\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("CanDrive", "${1:name}", function(ply, ent)\n\t$0\nend)'

[CanProperty]
type = 'interface'
description = 'Controls if a property can be used or not.\r\n```lua\rply: Player\r\n--Player, that tried to use the property\r\nproperty: string\r\n--Class of the property that is tried to use, for example - bonemanipulate\r\n\r\n<warning>This is not guaranteed to be the internal property name used in <page>properties.Add</page>!</warning>\r\nent: Entity\r\n--The entity, on which property is tried to be used on\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param property string\n---@param ent Entity'
customsnip = 'Add("CanProperty", "${1:name}", function(ply, property, ent)\n\t$0\nend)'

[CanTool]
type = 'interface'
description = 'Called when a player attempts to fire their tool gun. Return true to specifically allow the attempt, false to block it.\r\n```lua\rply: Player\r\n--The player who attempted to use their toolgun.\r\ntr: table\r\n--A trace from the players eye to where in the world their crosshair/cursor is pointing. See <page>Structures/TraceResult</page>\r\ntool: string\r\n--The tool mode the player currently has selected.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param ply Player\n---@param tr table\n---@param tool string'
customsnip = 'Add("CanTool", "${1:name}", function(ply, tr, tool)\n\t$0\nend)'

[ContentSidebarSelection]
type = 'interface'
description = 'Called when player selects an item on the spawnmenu sidebar at the left.\r\n```lua\rparent: Panel\r\n--The panel that holds spawnicons and the sidebar of spawnmenu\r\nnode: Panel\r\n--The item player selected\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param parent Panel\n---@param node Panel'
customsnip = 'Add("ContentSidebarSelection", "${1:name}", function(parent, node)\n\t$0\nend)'

[ContextMenuCreated]
type = 'interface'
description = 'Called when the context menu is created.\r\n```lua\rg_ContextMenu: Panel\r\n--The created context menu panel\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param g_ContextMenu Panel'
customsnip = 'Add("ContextMenuCreated", "${1:name}", function(g_ContextMenu)\n\t$0\nend)'

[ContextMenuOpen]
type = 'interface'
description = 'Called when the context menu is trying to be opened. Return false to disallow it.\r\n\r\n**Scope:** Client'
customsnip = 'Add("ContextMenuOpen", "${1:name}", function()\n\t$0\nend)'

[PaintNotes]
type = 'interface'
description = 'Called from <page>GM:HUDPaint</page>; does nothing by default.\r\n\r\n<note>This cannot be used with <page>hook.Add</page></note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PaintNotes", "${1:name}", function()\n\t$0\nend)'

[PaintWorldTips]
type = 'interface'
description = 'Called from <page>GM:HUDPaint</page> to draw world tips. By default, enabling cl_drawworldtooltips will stop world tips from being drawn here.<br>\r\nSee <page>Global.AddWorldTip</page> for more information.\r\n\r\n<note>This cannot be used with <page>hook.Add</page></note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PaintWorldTips", "${1:name}", function()\n\t$0\nend)'

[PersistenceLoad]
type = 'interface'
description = 'Called when persistent props are loaded.\r\n```lua\rname: string\r\n--Save from which to load.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param name string'
customsnip = 'Add("PersistenceLoad", "${1:name}", function(name)\n\t$0\nend)'

[PersistenceSave]
type = 'interface'
description = 'Called when persistent props are saved.\r\n```lua\rname: string\r\n--Where to save. By default is convar "sbox_persist".\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param name string'
customsnip = 'Add("PersistenceSave", "${1:name}", function(name)\n\t$0\nend)'

[PlayerGiveSWEP]
type = 'interface'
description = 'Called when a player attempts to give themselves a weapon from the Q menu. ( Left mouse clicks on an icon )\r\n```lua\rply: Player\r\n--The player who attempted to give themselves a weapon.\r\nweapon: string\r\n--Class name of the weapon the player tried to give themselves.\r\nswep: table\r\n--The swep table of this weapon, see <page>Structures/SWEP</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param weapon string\n---@param swep table'
customsnip = 'Add("PlayerGiveSWEP", "${1:name}", function(ply, weapon, swep)\n\t$0\nend)'

[PlayerSpawnedEffect]
type = 'interface'
description = 'Called after the player spawned an effect.\r\n```lua\rply: Player\r\n--The player that spawned the effect\r\nmodel: string\r\n--The model of spawned effect\r\nent: Entity\r\n--The spawned effect itself\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string\n---@param ent Entity'
customsnip = 'Add("PlayerSpawnedEffect", "${1:name}", function(ply, model, ent)\n\t$0\nend)'

[PlayerSpawnedNPC]
type = 'interface'
description = 'Called after the player spawned an NPC.\r\n```lua\rply: Player\r\n--The player that spawned the NPC\r\nent: Entity\r\n--The spawned NPC itself\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PlayerSpawnedNPC", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PlayerSpawnedProp]
type = 'interface'
description = 'Called when a player has successfully spawned a prop from the Q menu.\r\n```lua\rply: Player\r\n--The player who spawned a prop.\r\nmodel: string\r\n--Path to the model of the prop the player is attempting to spawn.\r\nentity: Entity\r\n--The entity that was spawned.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string\n---@param entity Entity'
customsnip = 'Add("PlayerSpawnedProp", "${1:name}", function(ply, model, entity)\n\t$0\nend)'

[PlayerSpawnedRagdoll]
type = 'interface'
description = 'Called after the player spawned a ragdoll.\r\n```lua\rply: Player\r\n--The player that spawned the ragdoll\r\nmodel: string\r\n--The ragdoll model that player wants to spawn\r\nent: Entity\r\n--The spawned ragdoll itself\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string\n---@param ent Entity'
customsnip = 'Add("PlayerSpawnedRagdoll", "${1:name}", function(ply, model, ent)\n\t$0\nend)'

[PlayerSpawnedSENT]
type = 'interface'
description = 'Called after the player has spawned a scripted entity.\r\n```lua\rply: Player\r\n--The player that spawned the SENT\r\nent: Entity\r\n--The spawned SENT\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PlayerSpawnedSENT", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PlayerSpawnedSWEP]
type = 'interface'
description = 'Called after the player has spawned a scripted weapon from the spawnmenu with a middle mouse click.\r\n\r\nFor left mouse click spawns, see <page>SANDBOX:PlayerGiveSWEP</page>.\r\n```lua\rply: Player\r\n--The player that spawned the SWEP\r\nent: Entity\r\n--The SWEP itself\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PlayerSpawnedSWEP", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PlayerSpawnedVehicle]
type = 'interface'
description = 'Called after the player spawned a vehicle.\r\n```lua\rply: Player\r\n--The player that spawned the vehicle\r\nent: Entity\r\n--The vehicle itself\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param ent Entity'
customsnip = 'Add("PlayerSpawnedVehicle", "${1:name}", function(ply, ent)\n\t$0\nend)'

[PlayerSpawnEffect]
type = 'interface'
description = 'Called to ask if player allowed to spawn a particular effect or not.\r\n```lua\rply: Player\r\n--The player that wants to spawn an effect\r\nmodel: string\r\n--The effect model that player wants to spawn\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string'
customsnip = 'Add("PlayerSpawnEffect", "${1:name}", function(ply, model)\n\t$0\nend)'

[PlayerSpawnNPC]
type = 'interface'
description = 'Called to ask if player allowed to spawn a particular NPC or not.\r\n```lua\rply: Player\r\n--The player that wants to spawn that NPC\r\nnpc_type: string\r\n--The npc type that player is trying to spawn\r\nweapon: string\r\n--The weapon of that NPC\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param npc_type string\n---@param weapon string'
customsnip = 'Add("PlayerSpawnNPC", "${1:name}", function(ply, npc_type, weapon)\n\t$0\nend)'

[PlayerSpawnObject]
type = 'interface'
description = 'Called to ask whether player is allowed to spawn a given model. This includes props, effects, and ragdolls and is called before the respective PlayerSpawn* hook.\r\n```lua\rply: Player\r\n--The player in question\r\nmodel: string\r\n--Model path\r\nskin: number\r\n--Skin number\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string\n---@param skin number'
customsnip = 'Add("PlayerSpawnObject", "${1:name}", function(ply, model, skin)\n\t$0\nend)'

[PlayerSpawnProp]
type = 'interface'
description = 'Called when a player attempts to spawn a prop from the Q menu.\r\n```lua\rply: Player\r\n--The player who attempted to spawn a prop.\r\nmodel: string\r\n--Path to the model of the prop the player is attempting to spawn.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string'
customsnip = 'Add("PlayerSpawnProp", "${1:name}", function(ply, model)\n\t$0\nend)'

[PlayerSpawnRagdoll]
type = 'interface'
description = 'Called when a player attempts to spawn a ragdoll from the Q menu.\r\n```lua\rply: Player\r\n--The player who attempted to spawn a ragdoll.\r\nmodel: string\r\n--Path to the model of the ragdoll the player is attempting to spawn.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string'
customsnip = 'Add("PlayerSpawnRagdoll", "${1:name}", function(ply, model)\n\t$0\nend)'

[PlayerSpawnSENT]
type = 'interface'
description = 'Called when a player attempts to spawn an Entity from the Q menu.\r\n```lua\rply: Player\r\n--The player who attempted to spawn the entity.\r\nclass: string\r\n--Class name of the entity the player tried to spawn.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param class string'
customsnip = 'Add("PlayerSpawnSENT", "${1:name}", function(ply, class)\n\t$0\nend)'

[PlayerSpawnSWEP]
type = 'interface'
description = 'Called when a player attempts to spawn a weapon from the Q menu. ( Mouse wheel clicks on an icon )\r\n```lua\rply: Player\r\n--The player who attempted to spawn a weapon.\r\nweapon: string\r\n--Class name of the weapon the player tried to spawn.\r\nswep: table\r\n--Information about the weapon the player is trying to spawn, see <page>Structures/SWEP</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param weapon string\n---@param swep table'
customsnip = 'Add("PlayerSpawnSWEP", "${1:name}", function(ply, weapon, swep)\n\t$0\nend)'

[PlayerSpawnVehicle]
type = 'interface'
description = 'Called to ask if player allowed to spawn a particular vehicle or not.\r\n```lua\rply: Player\r\n--The player that wants to spawn that vehicle\r\nmodel: string\r\n--The vehicle model that player wants to spawn\r\nname: string\r\n--Vehicle name\r\ntable: table\r\n--Table of that vehicle, containing info about it\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player\n---@param model string\n---@param name string\n---@param table table'
customsnip = 'Add("PlayerSpawnVehicle", "${1:name}", function(ply, model, name, table)\n\t$0\nend)'

[PopulatePropMenu]
type = 'interface'
description = 'This hook makes the engine load the spawnlist text files.\r\nIt calls <page>spawnmenu.PopulateFromEngineTextFiles</page> by default.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PopulatePropMenu", "${1:name}", function()\n\t$0\nend)'

[PopulateSTOOLMenu]
type = 'interface'
description = 'Called to populate the Scripted Tool menu.\r\n\r\n<deprecated>This hook is never called. Use <page>SANDBOX:PopulateToolMenu</page> instead.</deprecated>\r\n\r\n**Scope:** Client'
customsnip = 'Add("PopulateSTOOLMenu", "${1:name}", function()\n\t$0\nend)'

[PopulateToolMenu]
type = 'interface'
description = 'Add the STOOLS to the tool menu. You want to call <page>spawnmenu.AddToolMenuOption</page> in this hook.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PopulateToolMenu", "${1:name}", function()\n\t$0\nend)'

[PostReloadToolsMenu]
type = 'interface'
description = 'Called right after the Lua Loaded tool menus are reloaded. This is a good place to set up any <page>ControlPanel</page>s.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PostReloadToolsMenu", "${1:name}", function()\n\t$0\nend)'

[PreReloadToolsMenu]
type = 'interface'
description = 'Called right before the Lua Loaded tool menus are reloaded.\r\n\r\n**Scope:** Client'
customsnip = 'Add("PreReloadToolsMenu", "${1:name}", function()\n\t$0\nend)'

[SpawnMenuEnabled]
type = 'interface'
description = 'If false is returned then the spawn menu is never created. This saves load times if your mod doesn\'t actually use the spawn menu for any reason.\r\n\r\n**Scope:** Client'
customsnip = 'Add("SpawnMenuEnabled", "${1:name}", function()\n\t$0\nend)'

[SpawnMenuOpen]
type = 'interface'
description = 'Called when spawnmenu is trying to be opened.\r\n\r\n<note>Hiding the spawnmenu will not stop people from being able to use the various console commands to spawn in items, etc. See GM:PlayerSpawn* hooks for blocking actual spawning.</note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("SpawnMenuOpen", "${1:name}", function()\n\t$0\nend)'

[Deploy]
type = 'interface'
description = 'Called when <page>WEAPON:Deploy</page> of the toolgun is called.\r\n\r\nThis is also called when switching from another tool on the server.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Deploy", "${1:name}", function()\n\t$0\nend)'

[DrawHUD]
type = 'interface'
description = 'Called when <page>WEAPON:DrawHUD</page> of the toolgun is called, only when the user has this tool selected.\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawHUD", "${1:name}", function()\n\t$0\nend)'

[DrawToolScreen]
type = 'interface'
description = 'Called after the default tool screen has been drawn from <page>WEAPON:RenderScreen</page>.\r\n\r\n<note>If this method exists on the TOOL object table, the default scrolling text will not be drawn</note>\r\n<note>Materials rendered in this hook require $ignorez parameter to draw properly.</note>\r\n```lua\rwidth: number\r\n--The width of the tool\'s screen in pixels.\r\nheight: number\r\n--The height of the tool\'s screen in pixels.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param width number\n---@param height number'
customsnip = 'Add("DrawToolScreen", "${1:name}", function(width, height)\n\t$0\nend)'

[FreezeMovement]
type = 'interface'
description = 'Called when <page>WEAPON:Think</page> of the toolgun is called, only when the user has this tool selected.\r\n\r\n**Scope:** Client'
customsnip = 'Add("FreezeMovement", "${1:name}", function()\n\t$0\nend)'

[Holster]
type = 'interface'
description = 'Called when <page>WEAPON:Holster</page> of the toolgun is called, as well as when switching between different toolguns.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Holster", "${1:name}", function()\n\t$0\nend)'

[LeftClick]
type = 'interface'
description = 'Called when the user left clicks with the tool\r\n```lua\rtr: table\r\n--A trace from users eyes to wherever he aims at. See <page>Structures/TraceResult</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param tr table'
customsnip = 'Add("LeftClick", "${1:name}", function(tr)\n\t$0\nend)'

[Reload]
type = 'interface'
description = 'Called when the user presses the reload key with the tool out.\r\n```lua\rtr: table\r\n--A trace from users eyes to wherever he aims at. See <page>Structures/TraceResult</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param tr table'
customsnip = 'Add("Reload", "${1:name}", function(tr)\n\t$0\nend)'

[RightClick]
type = 'interface'
description = 'Called when the user right clicks with the tool.\r\n```lua\rtr: table\r\n--A trace from users eyes to wherever he aims at. See <page>Structures/TraceResult</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param tr table'
customsnip = 'Add("RightClick", "${1:name}", function(tr)\n\t$0\nend)'

[Think]
type = 'interface'
description = 'Called when <page>WEAPON:Think</page> of the toolgun is called. This only happens when the tool gun is currently equipped/selected by the player and the selected tool is this tool.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Think", "${1:name}", function()\n\t$0\nend)'

[AcceptInput]
type = 'interface'
description = 'Called when another entity fires an event to this entity.\r\n```lua\rinputName: string\r\n--The name of the input that was triggered.\r\nactivator: Entity\r\n--The initial cause for the input getting triggered.\r\ncalled: Entity\r\n--The entity that directly trigger the input.\r\ndata: string\r\n--The data passed.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param inputName string\n---@param activator Entity\n---@param called Entity\n---@param data string'
customsnip = 'Add("AcceptInput", "${1:name}", function(inputName, activator, called, data)\n\t$0\nend)'

[AdjustMouseSensitivity]
type = 'interface'
description = 'Allows you to adjust the mouse sensitivity. This hook only works if you haven\'t overridden <page>GM:AdjustMouseSensitivity</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("AdjustMouseSensitivity", "${1:name}", function()\n\t$0\nend)'

[Ammo1]
type = 'interface'
description = 'Returns how much of primary ammo the player has.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Ammo1", "${1:name}", function()\n\t$0\nend)'

[Ammo2]
type = 'interface'
description = 'Returns how much of secondary ammo the player has.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Ammo2", "${1:name}", function()\n\t$0\nend)'

[CalcView]
type = 'interface'
description = 'Allows you to adjust player view while this weapon in use.\r\n\r\nThis hook is called from the default implementation of <page>GM:CalcView</page> which is [here](https://github.com/garrynewman/garrysmod/blob/master/garrysmod/gamemodes/base/gamemode/cl_init.lua#L376-L383). Therefore, it will not be called if any other hook added to CalcView returns any value, or if the current gamemode overrides the default hook and does not call the SWEP function.\r\n\r\n<bug pull="1348">SWEPs that define this function will not work with the <page text="taunt camera.">Global.TauntCamera</page></bug>\r\n```lua\rply: Player\r\n--The owner of weapon\r\npos: Vector\r\n--Current position of players view\r\nang: Angle\r\n--Current angles of players view\r\nfov: number\r\n--Current FOV of players view\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ply Player\n---@param pos Vector\n---@param ang Angle\n---@param fov number'
customsnip = 'Add("CalcView", "${1:name}", function(ply, pos, ang, fov)\n\t$0\nend)'

[CalcViewModelView]
type = 'interface'
description = 'Allows overriding the position and angle of the viewmodel. This hook only works if you haven\'t overridden <page>GM:CalcViewModelView</page>.\r\n```lua\rViewModel: Entity\r\n--The viewmodel entity\r\nOldEyePos: Vector\r\n--Original position (before viewmodel bobbing and swaying)\r\nOldEyeAng: Angle\r\n--Original angle (before viewmodel bobbing and swaying)\r\nEyePos: Vector\r\n--Current position\r\nEyeAng: Angle\r\n--Current angle\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ViewModel Entity\n---@param OldEyePos Vector\n---@param OldEyeAng Angle\n---@param EyePos Vector\n---@param EyeAng Angle'
customsnip = 'Add("CalcViewModelView", "${1:name}", function(ViewModel, OldEyePos, OldEyeAng, EyePos, EyeAng)\n\t$0\nend)'

[CanBePickedUpByNPCs]
type = 'interface'
description = 'Called when a Citizen NPC is looking around to a (better) weapon to pickup.\r\n\r\n**Scope:** Server'
customsnip = 'Add("CanBePickedUpByNPCs", "${1:name}", function()\n\t$0\nend)'

[CanPrimaryAttack]
type = 'interface'
description = 'Helper function for checking for no ammo.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("CanPrimaryAttack", "${1:name}", function()\n\t$0\nend)'

[CanSecondaryAttack]
type = 'interface'
description = 'Helper function for checking for no ammo.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("CanSecondaryAttack", "${1:name}", function()\n\t$0\nend)'

[CustomAmmoDisplay]
type = 'interface'
description = 'Allows you to use any numbers you want for the ammo display on the HUD.\r\n\r\nCan be useful for weapons that don\'t use standard ammo.\r\n\r\n**Scope:** Client'
customsnip = 'Add("CustomAmmoDisplay", "${1:name}", function()\n\t$0\nend)'

[Deploy]
type = 'interface'
description = 'Called when player has just switched to this weapon.\r\n\r\n<note>Due to this hook being predicted, it is not called clientside in singleplayer at all, and in multiplayer it will not be called clientside if the weapon is switched with <page>Player:SelectWeapon</page> or the "use" console command, however it will be called clientside with the default weapon selection menu and when using <page>CUserCmd:SelectWeapon</page></note>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Deploy", "${1:name}", function()\n\t$0\nend)'

[DoDrawCrosshair]
type = 'interface'
description = 'Called when the crosshair is about to get drawn, and allows you to override it.\r\n\r\n<note>This function will not be called if **SWEP.DrawCrosshair** set to false.</note>\r\n<note>This function will not be called if player was affected by <page>Player:CrosshairDisable</page>.</note>\r\n\r\n<bug issue="2117">The arguments passed to this function are not affected by **SWEP.AccurateCrosshair**.</bug>\r\n```lua\rx: number\r\n--X coordinate of the crosshair.\r\ny: number\r\n--Y coordinate of the crosshair.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param x number\n---@param y number'
customsnip = 'Add("DoDrawCrosshair", "${1:name}", function(x, y)\n\t$0\nend)'

[DoImpactEffect]
type = 'interface'
description = 'Called so the weapon can override the impact effects it makes.\r\n```lua\rtr: table\r\n--A <page>Structures/TraceResult</page> from player\'s eyes to the impact point\r\ndamageType: number\r\n--The damage type of bullet. See <page>Enums/DMG</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param tr table\n---@param damageType number'
customsnip = 'Add("DoImpactEffect", "${1:name}", function(tr, damageType)\n\t$0\nend)'

[DrawHUD]
type = 'interface'
description = 'This hook allows you to draw on screen while this weapon is in use.\r\n\r\nIf you want to draw a custom crosshair, consider using <page>WEAPON:DoDrawCrosshair</page> instead.\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawHUD", "${1:name}", function()\n\t$0\nend)'

[DrawHUDBackground]
type = 'interface'
description = 'This hook allows you to draw on screen while this weapon is in use. This hook is called **before** <page>WEAPON:DrawHUD</page> and is equivalent of <page>GM:HUDPaintBackground</page>.\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawHUDBackground", "${1:name}", function()\n\t$0\nend)'

[DrawWeaponSelection]
type = 'interface'
description = 'This hook draws the selection icon in the weapon selection menu.\r\n```lua\rx: number\r\n--X coordinate of the selection panel\r\ny: number\r\n--Y coordinate of the selection panel\r\nwidth: number\r\n--Width of the selection panel\r\nheight: number\r\n--Height of the selection panel\r\nalpha: number\r\n--Alpha value of the selection panel\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param x number\n---@param y number\n---@param width number\n---@param height number\n---@param alpha number'
customsnip = 'Add("DrawWeaponSelection", "${1:name}", function(x, y, width, height, alpha)\n\t$0\nend)'

[DrawWorldModel]
type = 'interface'
description = 'Called when we are about to draw the world model.\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawWorldModel", "${1:name}", function()\n\t$0\nend)'

[DrawWorldModelTranslucent]
type = 'interface'
description = 'Called when we are about to draw the translucent world model.\r\n\r\n**Scope:** Client'
customsnip = 'Add("DrawWorldModelTranslucent", "${1:name}", function()\n\t$0\nend)'

[Equip]
type = 'interface'
description = 'Called when a player or NPC has picked the weapon up.\r\n```lua\rNewOwner: Entity\r\n--The one who picked the weapon up. Can be <page>Player</page> or <page>NPC</page>.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param NewOwner Entity'
customsnip = 'Add("Equip", "${1:name}", function(NewOwner)\n\t$0\nend)'

[EquipAmmo]
type = 'interface'
description = 'The player has picked up the weapon and has taken the ammo from it.\r\nThe weapon will be removed immidiately after this call.\r\n```lua\rply: Player\r\n--The player who picked up the weapon\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param ply Player'
customsnip = 'Add("EquipAmmo", "${1:name}", function(ply)\n\t$0\nend)'

[FireAnimationEvent]
type = 'interface'
description = 'Called before firing animation events, such as muzzle flashes or shell ejections.\r\n\r\nThis will only be called serverside for 3000-range events, and clientside for 5000-range  and other events.\r\n```lua\rpos: Vector\r\n--Position of the effect.\r\nang: Angle\r\n--Angle of the effect.\r\nevent: number\r\n--The event ID of happened even. See [this page](http://developer.valvesoftware.com/wiki/Animation_Events).\r\noptions: string\r\n--Name or options of the event.\r\nsource: Entity\r\n--The source entity. This will be a viewmodel on the client and the weapon itself on the server\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param pos Vector\n---@param ang Angle\n---@param event number\n---@param options string\n---@param source Entity'
customsnip = 'Add("FireAnimationEvent", "${1:name}", function(pos, ang, event, options, source)\n\t$0\nend)'

[FreezeMovement]
type = 'interface'
description = 'This hook allows you to freeze players screen.\r\n<note>Player will still be able to move or shoot</note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("FreezeMovement", "${1:name}", function()\n\t$0\nend)'

[GetCapabilities]
type = 'interface'
description = 'This hook is for NPCs, you return what they should try to do with it.\r\n\r\n**Scope:** Server'
customsnip = 'Add("GetCapabilities", "${1:name}", function()\n\t$0\nend)'

[GetNPCBulletSpread]
type = 'interface'
description = 'Called when the weapon is used by NPCs to determine how accurate the bullets fired should be.\r\n\r\nThe inaccuracy is simulated by changing the <page>NPC:GetAimVector</page> based on the value returned from this hook.\r\n```lua\rproficiency: number\r\n--How proficient the NPC is with this gun. See <page>Enums/WEAPON_PROFICIENCY</page>\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param proficiency number'
customsnip = 'Add("GetNPCBulletSpread", "${1:name}", function(proficiency)\n\t$0\nend)'

[GetNPCBurstSettings]
type = 'interface'
description = 'Called when the weapon is used by NPCs to tell the NPC how to use this weapon. Controls how long the NPC can or should shoot continuously.\r\n\r\n**Scope:** Server'
customsnip = 'Add("GetNPCBurstSettings", "${1:name}", function()\n\t$0\nend)'

[GetNPCRestTimes]
type = 'interface'
description = 'Called when the weapon is used by NPCs to tell the NPC how to use this weapon. Controls amount of time the NPC can rest (not shoot) between bursts.\r\n\r\n<bug>Has no effect on Combine Soldiers, will be fixed in the next update</bug>\r\n\r\n**Scope:** Server'
customsnip = 'Add("GetNPCRestTimes", "${1:name}", function()\n\t$0\nend)'

[GetTracerOrigin]
type = 'interface'
description = 'Allows you to override where the tracer effect comes from. ( Visual bullets )\r\n\r\n**Scope:** Client'
customsnip = 'Add("GetTracerOrigin", "${1:name}", function()\n\t$0\nend)'

[GetViewModelPosition]
type = 'interface'
description = 'This hook allows you to adjust view model position and angles.\r\n```lua\rEyePos: Vector\r\n--Current position\r\nEyeAng: Angle\r\n--Current angle\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param EyePos Vector\n---@param EyeAng Angle'
customsnip = 'Add("GetViewModelPosition", "${1:name}", function(EyePos, EyeAng)\n\t$0\nend)'

[Holster]
type = 'interface'
description = 'Called when weapon tries to holster.\r\n\r\n<note>This will only be called serverside when using <page>Player:SelectWeapon</page> as that function immidiately switches the weapon out of prediction.</note>\r\n\r\n<bug issue="2854">This is called twice for every holster clientside, one in <page>Prediction</page> and one not.</bug>\r\n\r\n<bug issue="3133">Before <page>WEAPON:OnRemove</page> is called, this function is only called serverside.</bug>\r\n```lua\rweapon: Entity\r\n--The weapon we are trying switch to.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param weapon Entity'
customsnip = 'Add("Holster", "${1:name}", function(weapon)\n\t$0\nend)'

[HUDShouldDraw]
type = 'interface'
description = 'This hook determines which parts of the HUD to draw.\r\n```lua\relement: string\r\n--The HUD element in question\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param element string'
customsnip = 'Add("HUDShouldDraw", "${1:name}", function(element)\n\t$0\nend)'

[Initialize]
type = 'interface'
description = 'Called when the weapon entity is created.\r\n\r\n<note><page>Entity:GetOwner</page> will return NULL at this point because the weapon is not equpped by a player or NPC yet. Use <page>WEAPON:Equip</page> or <page>WEAPON:Deploy</page> if you need the owner to be valid.</note>\r\n\r\n<bug issue="2732">This is sometimes not called clientside. You can work around this by setting a variable in Initialize and check if it exists in <page>WEAPON:Think</page>. See the example below.</bug>\r\n\r\n<bug issue="3015">This is not called serverside after a quicksave.</bug>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Initialize", "${1:name}", function()\n\t$0\nend)'

[KeyValue]
type = 'interface'
description = 'Called when the engine sets a value for this scripted weapon.\r\n\r\nSee <page>GM:EntityKeyValue</page> for a hook that works for all entities.\r\n\r\n\r\nSee <page>ENTITY:KeyValue</page> for an  hook that works for scripted entities.\r\n```lua\rkey: string\r\n--The key that was affected.\r\nvalue: string\r\n--The new value.\r\n```\r\n\r\n**Scope:** Server'
comments = '---@param key string\n---@param value string'
customsnip = 'Add("KeyValue", "${1:name}", function(key, value)\n\t$0\nend)'

[OnDrop]
type = 'interface'
description = 'Called when weapon is dropped by <page>Player:DropWeapon</page>.\r\n\r\nSee also <page>WEAPON:OwnerChanged</page>.\r\n\r\n**Scope:** Server'
customsnip = 'Add("OnDrop", "${1:name}", function()\n\t$0\nend)'

[OnReloaded]
type = 'interface'
description = 'Called whenever the weapons Lua script is reloaded.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnReloaded", "${1:name}", function()\n\t$0\nend)'

[OnRemove]
type = 'interface'
description = 'Called when the swep is about to be removed.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnRemove", "${1:name}", function()\n\t$0\nend)'

[OnRestore]
type = 'interface'
description = 'Called when the weapon entity is reloaded from a Source Engine save (not the Sandbox saves or dupes) or on a changelevel (for example Half-Life 2 campaign level transitions).\r\n\r\nFor the <page>duplicator</page> callbacks, see <page>ENTITY:OnDuplicated</page>.\r\n\r\nSee also <page>saverestore</page> for relevant functions.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OnRestore", "${1:name}", function()\n\t$0\nend)'

[OwnerChanged]
type = 'interface'
description = 'Called when weapon is dropped or picked up by a new player.\r\n\r\nSee also <page>WEAPON:OnDrop</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("OwnerChanged", "${1:name}", function()\n\t$0\nend)'

[PostDrawViewModel]
type = 'interface'
description = 'Called after the view model has been drawn while the weapon in use. This hook is called from the default implementation of <page>GM:PostDrawViewModel</page>, and as such, will not occur if it has been overridden.\r\n\r\n<page>WEAPON:ViewModelDrawn</page> is an alternative hook which is always called before <page>GM:PostDrawViewModel</page>.\r\n```lua\rvm: Entity\r\n--This is the view model entity after it is drawn\r\nweapon: Weapon\r\n--This is the weapon that is from the view model (same as self)\r\nply: Player\r\n--The owner of the view model\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param vm Entity\n---@param weapon Weapon\n---@param ply Player'
customsnip = 'Add("PostDrawViewModel", "${1:name}", function(vm, weapon, ply)\n\t$0\nend)'

[PreDrawViewModel]
type = 'interface'
description = 'Allows you to modify viewmodel while the weapon in use before it is drawn. This hook only works if you haven\'t overridden <page>GM:PreDrawViewModel</page>.\r\n```lua\rvm: Entity\r\n--This is the view model entity before it is drawn.\r\nweapon: Weapon\r\n--This is the weapon that is from the view model.\r\nply: Player\r\n--The the owner of the view model.\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param vm Entity\n---@param weapon Weapon\n---@param ply Player'
customsnip = 'Add("PreDrawViewModel", "${1:name}", function(vm, weapon, ply)\n\t$0\nend)'

[PrimaryAttack]
type = 'interface'
description = 'Called when primary attack button ( +attack ) is pressed.\r\n\r\nWhen in singleplayer, this function is only called in the server realm. When in multiplayer, the hook will be called on both the server and the client in order to allow for <page>Prediction</page>.\r\n\r\nYou can force the hook to always be called on client like this:\r\n\r\n```\r\nif ( game.SinglePlayer() ) then self:CallOnClient( "PrimaryAttack" ) end\r\n```\r\n\r\n\r\nNote that due to prediction, in multiplayer SWEP:PrimaryAttack is called multiple times per one "shot" with the gun. To work around that, use <page>Global.IsFirstTimePredicted</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("PrimaryAttack", "${1:name}", function()\n\t$0\nend)'

[PrintWeaponInfo]
type = 'interface'
description = 'A convenience function that draws the weapon info box, used in <page>WEAPON:DrawWeaponSelection</page>.\r\n```lua\rx: number\r\n--The x co-ordinate of box position\r\ny: number\r\n--The y co-ordinate of box position\r\nalpha: number\r\n--Alpha value for the box\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param x number\n---@param y number\n---@param alpha number'
customsnip = 'Add("PrintWeaponInfo", "${1:name}", function(x, y, alpha)\n\t$0\nend)'

[Reload]
type = 'interface'
description = 'Called when the reload key ( +reload ) is pressed.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Reload", "${1:name}", function()\n\t$0\nend)'

[RenderScreen]
type = 'interface'
description = 'Called every frame just before <page>GM:RenderScene</page>.\r\n\r\nUsed by the Tool Gun to render view model screens (<page>TOOL:DrawToolScreen</page>).\r\n\r\n\r\n<note>Materials rendered in this hook require $ignorez parameter to draw properly.</note>\r\n\r\n**Scope:** Client'
customsnip = 'Add("RenderScreen", "${1:name}", function()\n\t$0\nend)'

[SecondaryAttack]
type = 'interface'
description = 'Called when secondary attack button ( +attack2 ) is pressed.\r\n\r\nFor issues with this hook being called rapidly on the client side, see the global function <page>Global.IsFirstTimePredicted</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("SecondaryAttack", "${1:name}", function()\n\t$0\nend)'

[SetDeploySpeed]
type = 'interface'
description = 'Sets the weapon deploy speed. This value needs to match on client and server.\r\n```lua\rspeed: number\r\n--The value to set deploy speed to. Negative will slow down playback.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param speed number'
customsnip = 'Add("SetDeploySpeed", "${1:name}", function(speed)\n\t$0\nend)'

[SetupDataTables]
type = 'interface'
description = 'Called when the SWEP should set up its <page text=" Data Tables">Networking_Entities</page>.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("SetupDataTables", "${1:name}", function()\n\t$0\nend)'

[SetWeaponHoldType]
type = 'interface'
description = 'Sets the hold type of the weapon. This must be called on **both** the server and the client to work properly.\r\n\r\n**NOTE:** You should avoid calling this function and call <page>Weapon:SetHoldType</page> now.\r\n```lua\rname: string\r\n--Name of the hold type. You can find all default hold types <page text="here">Hold_Types</page>\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param name string'
customsnip = 'Add("SetWeaponHoldType", "${1:name}", function(name)\n\t$0\nend)'

[ShootBullet]
type = 'interface'
description = 'A convenient function to shoot bullets.\r\n```lua\rdamage: number\r\n--The damage of the bullet\r\nnum_bullets: number\r\n--Amount of bullets to shoot\r\naimcone: number\r\n--Spread of bullets\r\nammo_type: string\r\n--Ammo type of the bullets\r\nforce: number\r\n--Force of the bullets\r\ntracer: number\r\n--Show a tracer on every x bullets\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param damage number\n---@param num_bullets number\n---@param aimcone number\n---@param ammo_type string\n---@param force number\n---@param tracer number'
customsnip = 'Add("ShootBullet", "${1:name}", function(damage, num_bullets, aimcone, ammo_type, force, tracer)\n\t$0\nend)'

[ShootEffects]
type = 'interface'
description = 'A convenience function to create shoot effects.\r\n\r\n**Scope:** Shared'
customsnip = 'Add("ShootEffects", "${1:name}", function()\n\t$0\nend)'

[ShouldDrawViewModel]
type = 'interface'
description = 'Called to determine if the view model should be drawn or not.\r\n\r\n**Scope:** Client'
customsnip = 'Add("ShouldDrawViewModel", "${1:name}", function()\n\t$0\nend)'

[ShouldDropOnDie]
type = 'interface'
description = 'Should this weapon be dropped when its owner dies?\r\n\r\nThis only works if the player has <page>Player:ShouldDropWeapon</page> set to true.\r\n\r\n**Scope:** Server'
customsnip = 'Add("ShouldDropOnDie", "${1:name}", function()\n\t$0\nend)'

[TakePrimaryAmmo]
type = 'interface'
description = 'A convenience function to remove primary ammo from clip.\r\n```lua\ramount: number\r\n--Amount of primary ammo to remove\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param amount number'
customsnip = 'Add("TakePrimaryAmmo", "${1:name}", function(amount)\n\t$0\nend)'

[TakeSecondaryAmmo]
type = 'interface'
description = 'A convenience function to remove secondary ammo from clip.\r\n```lua\ramount: number\r\n--How much of secondary ammo to remove\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param amount number'
customsnip = 'Add("TakeSecondaryAmmo", "${1:name}", function(amount)\n\t$0\nend)'

[Think]
type = 'interface'
description = 'Called when the swep thinks.\r\n\r\nThis hook won\'t be called during the deploy animation and when using <page>Weapon:DefaultReload</page>.\r\n\r\n<note>Despite being a predicted hook, this hook is called clientside in single player, however it will not be recognized as a predicted hook to <page>Player:GetCurrentCommand</page>.</note>\r\n\r\n<note>This hook will be called before Player movement is processed on the client, and after on the server.</note>\r\n\r\n<bug issue="2855">This will not be run during deploy animations after a serverside-only deploy. This usually happens after picking up and dropping an object with +use.</bug>\r\n\r\n**Scope:** Shared'
customsnip = 'Add("Think", "${1:name}", function()\n\t$0\nend)'

[TranslateActivity]
type = 'interface'
description = 'Translate a player\'s Activity into a weapon\'s activity, depending on how you want the player to be holding the weapon.\r\n\r\nFor example, ACT_MP_RUN becomes ACT_HL2MP_RUN_PISTOL.\r\n```lua\ract: number\r\n--The activity to translate\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param act number'
customsnip = 'Add("TranslateActivity", "${1:name}", function(act)\n\t$0\nend)'

[TranslateFOV]
type = 'interface'
description = 'Allows to change players field of view while player holds the weapon.\r\n\r\n<note>This hook must be defined shared and return same value on both to properly affect Area Portals.</note>\r\n```lua\rfov: number\r\n--The current/default FOV.\r\n```\r\n\r\n**Scope:** Shared'
comments = '---@param fov number'
customsnip = 'Add("TranslateFOV", "${1:name}", function(fov)\n\t$0\nend)'

[ViewModelDrawn]
type = 'interface'
description = 'Called straight after the view model has been drawn. This is called before <page>GM:PostDrawViewModel</page> and <page>WEAPON:PostDrawViewModel</page>.\r\n```lua\rViewModel: Entity\r\n--Players view model\r\n```\r\n\r\n**Scope:** Client'
comments = '---@param ViewModel Entity'
customsnip = 'Add("ViewModelDrawn", "${1:name}", function(ViewModel)\n\t$0\nend)'


